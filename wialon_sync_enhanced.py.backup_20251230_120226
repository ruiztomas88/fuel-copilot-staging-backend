"""
Wialon to MySQL Sync - Enhanced Real-time Data Bridge v3.0
ğŸš€ FULL KALMAN FILTER INTEGRATION + QUICK WINS

This enhanced sync script properly integrates:
- FuelEstimator (Kalman Filter) from estimator.py
- MPG tracking from mpg_engine.py
- Idle consumption calculation from idle_engine.py
- State persistence for continuity across restarts
- ğŸ†• v3.12.32: Quick Wins (Adaptive Thresholds, Confidence Scoring, Smart Notifications, Sensor Health)

FIXES ALL DASHBOARD ISSUES:
âœ… Kalman vs Sensor values (not just N/A)
âœ… Proper drift calculation (estimated - sensor)
âœ… Real MPG tracking with EMA smoothing
âœ… Idle consumption with temperature adjustment
âœ… Refuel detection with adaptive thresholds
âœ… Emergency reset for extreme drift
âœ… Confidence scoring for all estimations
âœ… Sensor health monitoring

Author: Fuel Copilot Team
Version: 3.12.32
Date: December 2025
"""

import json
import logging
import os
import threading
import time
from datetime import datetime, timedelta, timezone
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

# ğŸ”§ FIX DEC 23: Use pymysql instead of mysql.connector (not needed)
import pymysql
import yaml
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# ğŸ†• v3.12.32: Import Quick Wins modules
from adaptive_refuel_thresholds import get_adaptive_thresholds

# ğŸ†• v3.12.27: Import fuel event classifier for theft/sensor differentiation
from alert_service import (
    get_alert_manager,
    get_fuel_classifier,
    send_dtc_alert,
    send_sensor_issue_alert,
    send_theft_confirmed_alert,
    send_voltage_alert,
)
from confidence_scoring import calculate_estimation_confidence
from config import (
    get_allowed_trucks,
)  # ğŸ†• v5.4.6: Filter to only process configured trucks

# ğŸ†• v5.8.1: Import geofence functions for safe-zone theft detection
from database_mysql import GEOFENCE_ZONES, check_geofence_status, haversine_distance

# ğŸ†• v5.10.0: Import driver behavior engine for heavy foot detection
from driver_behavior_engine import BehaviorEvent, get_behavior_engine

# ğŸ†• v3.12.28: Import DTC analyzer for diagnostic code alerts
from dtc_analyzer import DTCSeverity, process_dtc_from_sensor_data

# ğŸ†• DEC 26 2025: Import HYBRID DTC decoder system (781,066 DTCs)
from dtc_decoder import FuelCopilotDTCHandler

# ğŸ†• DEC 23: Enhanced MPG calculation with environmental adjustments
from enhanced_mpg_calculator import EnhancedMPGCalculator, EnvironmentalFactors

# Import the existing sophisticated modules
from estimator import AnchorDetector, AnchorType, FuelEstimator

# ğŸ†• DEC 30 2025: FleetBooster integration for fuel levels & DTC alerts
from fleetbooster_integration import send_dtc_alert, send_fuel_level_update

# ğŸ†• v3.12.28: Import GPS quality for Kalman adaptive Q_L
from gps_quality import analyze_fleet_gps_quality, analyze_gps_quality
from idle_engine import IdleConfig  # ğŸ†• v5.7.3: For idle validation logging
from idle_engine import (
    IdleMethod,
    calculate_idle_consumption,
    detect_idle_mode,
    validate_idle_calculation,
)
from mpg_engine import MPGConfig, MPGState, reset_mpg_state, update_mpg_state

# ğŸ†• v5.11.0: Import predictive maintenance engine
from predictive_maintenance_engine import get_predictive_maintenance_engine
from sensor_health_monitor import get_sensor_health_monitor
from settings import get_settings  # ğŸ”§ DEC 23 FIX: Import at top level
from smart_refuel_notifications import get_refuel_notifier

# ğŸ†• v3.12.28: Import terrain factor for altitude-based consumption adjustment
from terrain_factor import get_terrain_fuel_factor

# ğŸ†• DEC 24 2025: Import truck specs engine for VIN-based MPG validation
from truck_specs_engine import get_truck_specs_engine, validate_truck_mpg

# ğŸ†• v3.12.28: Import voltage monitor for battery/alternator alerts
from voltage_monitor import (
    VoltageStatus,
    analyze_fleet_voltage,
    analyze_voltage,
    get_voltage_alert_manager,
)
from wialon_reader import TRUCK_UNIT_MAPPING, WialonConfig, WialonReader

# Configure logging with file handler
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
    handlers=[logging.FileHandler("wialon_sync.log"), logging.StreamHandler()],
)
logger = logging.getLogger(__name__)

# ğŸ†• FASES 2A, 2B, 2C: Extended Kalman Filter + ML Pipeline + Event-Driven Architecture
# Import AFTER logger is defined
try:
    from wialon_sync_2abc_integration import get_wialon_integration

    _wialon_2abc = get_wialon_integration()
    logger.info("âœ… Wialon 2ABC Integration loaded")
except ImportError as e:
    _wialon_2abc = None
    logger.warning(f"âš ï¸ Wialon 2ABC Integration not available: {e}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CONFIGURATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# ğŸ”§ FIX DEC 23: Use centralized config to support fuel_copilot_local for staging
try:
    from config import get_local_db_config

    _db_config = get_local_db_config()
    _db_config["autocommit"] = True
    LOCAL_DB_CONFIG = _db_config
    logger.info(f"âœ… Using database: {LOCAL_DB_CONFIG['database']}")
except ImportError:
    # Fallback if config.py not available
    LOCAL_DB_CONFIG = {
        "host": "localhost",
        "port": 3306,
        "user": "fuel_admin",
        "password": os.getenv("MYSQL_PASSWORD"),
        "database": os.getenv("MYSQL_DATABASE", "fuel_copilot"),
        "autocommit": True,
    }
    logger.warning(f"âš ï¸ Using fallback config, database: {LOCAL_DB_CONFIG['database']}")

# Alias for MPG loading function
DB_CONFIG = LOCAL_DB_CONFIG

# Security: Ensure password is set
if not LOCAL_DB_CONFIG.get("password"):
    # Try to get from environment if not set
    password = os.getenv("MYSQL_PASSWORD")
    if password:
        LOCAL_DB_CONFIG["password"] = password
    else:
        logger.warning("âš ï¸ MYSQL_PASSWORD not set, using root with no password")
        LOCAL_DB_CONFIG["user"] = "root"
        LOCAL_DB_CONFIG["password"] = ""

# ğŸ†• v6.5.1: Global MPG config for state initialization
mpg_config = MPGConfig()

# ğŸ†• DEC 26: Service container for dependency injection (replaces globals)
from service_container import get_container

# State persistence paths
DATA_DIR = Path(__file__).parent / "data"
ESTIMATOR_STATES_DIR = DATA_DIR / "estimator_states"
MPG_STATES_FILE = DATA_DIR / "mpg_states.json"

# Kalman configuration
# ğŸ”§ DEC 27 FIX: REVERTIDO a valores de producciÃ³n despuÃ©s de anÃ¡lisis de cÃ³digo
# HALLAZGO: ProducciÃ³n usa Q_L=4.0 con K clamp dinÃ¡mico (lÃ­neas 787-812 estimator.py)
# El K clamp previene overcorrection: k_max=0.20 cuando P<2.0 (alta confianza)
# Con Q_L=4.0 y P=1.0: K=0.20, pero clamp lo mantiene en 0.20
# InnovaciÃ³n grande (refuel, cambio real): k_max boost a 0.30-0.70
# MI ERROR: BajÃ© Q_L pensando que era el problema, pero el clamp ya lo maneja
KALMAN_CONFIG = {
    "Q_r": 0.05,  # Process noise (same as production v5.8.5)
    "Q_L_moving": 4.0,  # Measurement noise when moving (PRODUCTION VALUE)
    "Q_L_static": 1.0,  # Measurement noise when static (PRODUCTION VALUE)
    "max_drift_pct": 5.0,  # Drift warning threshold
    "emergency_drift_threshold": 30.0,  # Emergency reset threshold
    "emergency_gap_hours": 2.0,  # Time gap for emergency reset
    "refuel_volume_factor": 1.0,
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TANK CAPACITIES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


def load_tank_config() -> tuple[Dict[str, float], Dict[str, float]]:
    """Load tank capacities and refuel factors from tanks.yaml"""
    yaml_path = Path(__file__).parent / "tanks.yaml"
    capacities: Dict[str, float] = {"default": 200.0}
    refuel_factors: Dict[str, float] = {"default": 1.0}  # Default: no adjustment

    if yaml_path.exists():
        try:
            with open(yaml_path, "r", encoding="utf-8") as f:
                config = yaml.safe_load(f)
            trucks = config.get("trucks", {})
            for truck_id, truck_config in trucks.items():
                capacities[truck_id] = float(truck_config.get("capacity_gallons", 200))
                # Load refuel_factor if specified (for sensor calibration)
                if "refuel_factor" in truck_config:
                    refuel_factors[truck_id] = float(truck_config["refuel_factor"])
            logger.info(
                f"âœ… Loaded capacities for {len(trucks)} trucks from tanks.yaml"
            )
            factors_count = len([k for k in refuel_factors if k != "default"])
            if factors_count > 0:
                logger.info(f"âœ… Loaded refuel_factors for {factors_count} trucks")
        except Exception as e:
            logger.warning(f"âš ï¸ Could not load tanks.yaml: {e}")

    return capacities, refuel_factors


TANK_CAPACITIES, REFUEL_FACTORS = load_tank_config()


def get_refuel_factor(truck_id: str) -> float:
    """Get refuel factor for a truck (sensor calibration adjustment)"""
    return REFUEL_FACTORS.get(truck_id, REFUEL_FACTORS["default"])


def get_tank_capacity_liters(truck_id: str) -> float:
    """Get tank capacity in liters for a truck"""
    gallons = TANK_CAPACITIES.get(truck_id, TANK_CAPACITIES["default"])
    return gallons * 3.78541


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# DTC PROCESSING (HYBRID SYSTEM - DEC 26 2025)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


def parse_wialon_dtc_string(dtc_string: str) -> List[Tuple[int, int]]:
    """
    ğŸ†• DEC 26 2025: Parse Wialon DTC string into (SPN, FMI) tuples.

    Wialon sends DTCs as comma-separated values: "100.1,157.3,234.0"
    Each value is SPN.FMI where:
    - SPN: Suspect Parameter Number (before decimal)
    - FMI: Failure Mode Identifier (after decimal)

    Args:
        dtc_string: String from Wialon like "100.1,157.3"

    Returns:
        List of (spn, fmi) tuples: [(100, 1), (157, 3)]

    Examples:
        "100.1" â†’ [(100, 1)]
        "100.1,157.3" â†’ [(100, 1), (157, 3)]
        "0" â†’ [] (ignore invalid)
        "1.0" â†’ [] (ignore invalid)
    """
    if not dtc_string or dtc_string.strip() in ["", "0", "1", "0.0", "1.0"]:
        return []

    dtc_list = []
    for dtc_part in dtc_string.split(","):
        dtc_part = dtc_part.strip()
        if not dtc_part or dtc_part in ["0", "1", "0.0", "1.0"]:
            continue

        try:
            if "." in dtc_part:
                spn_str, fmi_str = dtc_part.split(".", 1)
                spn = int(float(spn_str))
                fmi = int(float(fmi_str))
            else:
                # If no decimal, treat as SPN only with FMI=31 (unknown)
                spn = int(float(dtc_part))
                fmi = 31

            # Validate ranges
            if spn > 0 and 0 <= fmi <= 31:
                dtc_list.append((spn, fmi))
            else:
                logger.warning(f"Invalid DTC ranges: SPN={spn}, FMI={fmi}")
        except (ValueError, AttributeError) as e:
            logger.warning(f"Could not parse DTC part '{dtc_part}': {e}")

    return dtc_list


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# STATE PERSISTENCE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


class StateManager:
    """Manages persistence of estimator and MPG states"""

    def __init__(self):
        ESTIMATOR_STATES_DIR.mkdir(parents=True, exist_ok=True)
        self.estimators: Dict[str, FuelEstimator] = {}
        self.mpg_states: Dict[str, MPGState] = {}
        self.anchor_detectors: Dict[str, AnchorDetector] = {}
        self.last_sensor_data: Dict[str, Dict] = {}
        # ğŸ†• v5.7.2: Track idle hours for ECU validation
        self.idle_tracking: Dict[str, dict] = (
            {}
        )  # {truck_id: {calc_idle_hours, last_ecu_idle, last_check}}
        # ğŸ†• DEC24 2025: Track consumption with EMA filter for MPG calculation
        self.consumption_ema: Dict[str, float] = {}  # {truck_id: ema_consumption_gph}
        self.last_total_fuel: Dict[str, float] = (
            {}
        )  # {truck_id: last_total_fuel_used_gal}
        # ğŸ”§ v5.8.2: Thread safety lock for concurrent access
        self._lock = threading.RLock()
        self._load_states()

    def _load_states(self):
        """Load persisted states on startup"""
        # Load MPG states
        if MPG_STATES_FILE.exists():
            try:
                with open(MPG_STATES_FILE, "r") as f:
                    data = json.load(f)
                for truck_id, state_data in data.items():
                    mpg_state = MPGState(
                        distance_accum=state_data.get("distance_accum", 0.0),
                        fuel_accum_gal=state_data.get("fuel_accum_gal", 0.0),
                        mpg_current=state_data.get("mpg_current"),
                        window_count=state_data.get("window_count", 0),
                        last_fuel_lvl_pct=state_data.get("last_fuel_lvl_pct"),
                        last_odometer_mi=state_data.get("last_odometer_mi"),
                        last_timestamp=state_data.get("last_timestamp"),
                    )
                    self.mpg_states[truck_id] = mpg_state
                logger.info(f"âœ… Loaded MPG states for {len(self.mpg_states)} trucks")
            except Exception as e:
                logger.warning(f"âš ï¸ Could not load MPG states: {e}")

        # Load estimator states
        for state_file in ESTIMATOR_STATES_DIR.glob("*_state.json"):
            try:
                with open(state_file, "r") as f:
                    data = json.load(f)
                truck_id = data.get("truck_id")
                if truck_id:
                    capacity_liters = get_tank_capacity_liters(truck_id)
                    estimator = FuelEstimator(
                        truck_id=truck_id,
                        capacity_liters=capacity_liters,
                        config=KALMAN_CONFIG,
                    )
                    # Restore state
                    estimator.initialized = data.get("initialized", False)
                    estimator.level_liters = data.get("level_liters", 0.0)
                    estimator.level_pct = data.get("level_pct", 0.0)
                    estimator.L = data.get("L", 0.0)
                    estimator.P = data.get("P", 1.0)
                    estimator.P_L = data.get("P_L", 20.0)
                    estimator.drift_pct = data.get("drift_pct", 0.0)
                    estimator.last_fuel_lvl_pct = data.get("last_fuel_lvl_pct")
                    if data.get("last_timestamp"):
                        try:
                            estimator.last_update_time = datetime.fromisoformat(
                                data["last_timestamp"]
                            )
                        except (ValueError, TypeError) as e:
                            logger.debug(
                                f"Invalid timestamp format for {truck_id}: {e}"
                            )
                    self.estimators[truck_id] = estimator
            except Exception as e:
                logger.warning(f"âš ï¸ Could not load state from {state_file}: {e}")

        logger.info(f"âœ… Loaded estimator states for {len(self.estimators)} trucks")

    def get_estimator(self, truck_id: str) -> FuelEstimator:
        """Get or create estimator for a truck (thread-safe)"""
        with self._lock:
            if truck_id not in self.estimators:
                capacity_liters = get_tank_capacity_liters(truck_id)
                estimator = FuelEstimator(
                    truck_id=truck_id,
                    capacity_liters=capacity_liters,
                    config=KALMAN_CONFIG,
                )
                # ğŸ†• v6.2.0: Load calibrated physics model for ECU validation
                estimator.load_calibrated_params()
                self.estimators[truck_id] = estimator
            return self.estimators[truck_id]

    def get_mpg_state(self, truck_id: str) -> MPGState:
        """Get or create MPG state for a truck (thread-safe)

        ğŸ”§ v6.5.1: Load last valid MPG from DB if state doesn't exist
        This prevents "N.A" display after service restart - shows last known value
        """
        with self._lock:
            if truck_id not in self.mpg_states:
                # Try to load last valid MPG from database
                last_mpg = self._load_last_mpg_from_db(truck_id)
                self.mpg_states[truck_id] = MPGState(mpg_current=last_mpg)
            return self.mpg_states[truck_id]

    def _load_last_mpg_from_db(self, truck_id: str) -> Optional[float]:
        """Load last valid MPG from fuel_metrics table

        Args:
            truck_id: Truck identifier

        Returns:
            Last valid MPG (4.0-7.5 range) or None if not found
        """
        try:
            conn = pymysql.connect(**DB_CONFIG)
            cursor = conn.cursor()

            # Get last valid MPG from recent data (last 7 days)
            query = """
                SELECT mpg_current 
                FROM fuel_metrics 
                WHERE truck_id = %s 
                  AND mpg_current IS NOT NULL
                  AND mpg_current BETWEEN 3.5 AND 12.0
                  AND timestamp_utc >= NOW() - INTERVAL 7 DAY
                ORDER BY timestamp_utc DESC 
                LIMIT 1
            """
            cursor.execute(query, (truck_id,))
            result = cursor.fetchone()

            cursor.close()
            conn.close()

            if result:
                mpg = float(result[0])
                logger.debug(f"[{truck_id}] Loaded last valid MPG from DB: {mpg:.2f}")
                return mpg
            else:
                # No valid MPG in last 7 days - use fallback
                logger.debug(
                    f"[{truck_id}] No valid MPG in DB, using fallback: {mpg_config.fallback_mpg}"
                )
                return mpg_config.fallback_mpg

        except Exception as e:
            logger.warning(
                f"[{truck_id}] Could not load MPG from DB: {e}, using fallback"
            )
            return mpg_config.fallback_mpg

    def get_anchor_detector(self, truck_id: str) -> AnchorDetector:
        """Get or create anchor detector for a truck (thread-safe)"""
        with self._lock:
            if truck_id not in self.anchor_detectors:
                self.anchor_detectors[truck_id] = AnchorDetector(KALMAN_CONFIG)
            return self.anchor_detectors[truck_id]

    def save_states(self):
        """Persist all states to disk (thread-safe)"""
        with self._lock:
            # Save MPG states
            try:
                mpg_data = {}
                for truck_id, state in self.mpg_states.items():
                    mpg_data[truck_id] = {
                        "distance_accum": state.distance_accum,
                        "fuel_accum_gal": state.fuel_accum_gal,
                        "mpg_current": state.mpg_current,
                        "window_count": state.window_count,
                        "last_fuel_lvl_pct": state.last_fuel_lvl_pct,
                        "last_odometer_mi": state.last_odometer_mi,
                        "last_timestamp": state.last_timestamp,
                        "fuel_source_stats": state.fuel_source_stats,
                    }
                with open(MPG_STATES_FILE, "w") as f:
                    json.dump(mpg_data, f, indent=2)
                logger.debug(f"ğŸ’¾ Saved MPG states for {len(mpg_data)} trucks")
            except Exception as e:
                logger.error(f"Failed to save MPG states: {e}")

            # Save estimator states
            saved_count = 0
            for truck_id, estimator in self.estimators.items():
                try:
                    state_file = ESTIMATOR_STATES_DIR / f"{truck_id}_state.json"
                    state_data = {
                        "truck_id": truck_id,
                        "initialized": estimator.initialized,
                        "level_liters": estimator.level_liters,
                        "level_pct": estimator.level_pct,
                        "consumption_lph": estimator.consumption_lph,
                        "drift_pct": estimator.drift_pct,
                        "P": estimator.P,
                        "L": estimator.L,
                        "P_L": estimator.P_L,
                        "last_fuel_lvl_pct": estimator.last_fuel_lvl_pct,
                        "last_timestamp": (
                            estimator.last_update_time.isoformat()
                            if estimator.last_update_time
                            else None
                        ),
                        "saved_at": datetime.now(timezone.utc).isoformat(),
                        "mpg_current": (
                            self.mpg_states[truck_id].mpg_current
                            if truck_id in self.mpg_states
                            else None
                        ),
                    }
                    with open(state_file, "w") as f:
                        json.dump(state_data, f, indent=2)
                    saved_count += 1
                except Exception as e:
                    logger.error(f"Failed to save estimator state for {truck_id}: {e}")

            if saved_count > 0:
                logger.debug(f"ğŸ’¾ Saved estimator states for {saved_count} trucks")


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TRUCK PROCESSING LOGIC (FROM ORIGINAL fuel_copilot_v2_1_fixed.py)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


def determine_truck_status(
    speed: Optional[float],
    rpm: Optional[float],
    fuel_rate: Optional[float],
    data_age_min: float,
    pwr_ext: Optional[float] = None,
    engine_load: Optional[float] = None,
    coolant_temp: Optional[float] = None,
    sensor_timestamps: Optional[Dict[str, int]] = None,
) -> str:
    """
    Enhanced truck status determination v4 - Fixed timestamp validation

    ğŸ”§ FIX v3.12.31 (BUG-008): Validate sensor timestamps to prevent stale data mismatches
    Problem: Speed from 5 min ago + RPM from 30 sec ago = wrong status
    Solution: Use only sensors with similar timestamps (within 2 min of each other)

    Status Hierarchy:
    1. OFFLINE: Data too old (>15 min)
    2. STOPPED: Engine ON but stationary (RPM > 0, speed = 0 or None) - IDLING
    3. MOVING: Vehicle in motion (speed > 2 mph)
    4. PARKED: Engine OFF, vehicle connected (shore power or recent data)
    5. OFFLINE: No activity detected

    Engine ON Indicators (any one = engine running):
    - RPM > 0
    - Fuel rate > 0.3 L/h
    - Engine load > 0%
    - Coolant temp > 120Â°F (engine at operating temp)

    Args:
        sensor_timestamps: Dict with sensor ages in seconds: {'speed': 300, 'rpm': 30, ...}
    """
    # Check for offline - stale data (no communication in 15+ minutes)
    if data_age_min > 15:
        return "OFFLINE"

    # ğŸ†• BUG-008 FIX: Validate sensor timestamps before using them
    # If speed data is >2 min older than RPM, don't trust speed (may be stale)
    if sensor_timestamps:
        speed_age = sensor_timestamps.get("speed", 0)
        rpm_age = sensor_timestamps.get("rpm", 0)

        # If speed is MUCH older than RPM (>2 min difference), ignore speed
        # This prevents "speed=0 from 5 min ago" + "rpm=1500 now" = wrong STOPPED
        if speed is not None and rpm is not None:
            age_diff = abs(speed_age - rpm_age)
            if age_diff > 120:  # 2 minutes difference
                if speed_age > rpm_age + 120:
                    # Speed is stale compared to RPM - ignore it
                    speed = None
                    logger.debug(
                        f"Ignoring stale speed (age={speed_age}s vs rpm age={rpm_age}s)"
                    )
                elif rpm_age > speed_age + 120:
                    # RPM is stale compared to speed - ignore it
                    rpm = None
                    logger.debug(
                        f"Ignoring stale rpm (age={rpm_age}s vs speed age={speed_age}s)"
                    )

    # ğŸ”§ FIX v3.12.1: Check engine indicators FIRST (before speed check)
    # This ensures trucks with RPM > 0 but speed=None are marked STOPPED, not OFFLINE
    rpm_val = rpm or 0
    fuel_rate_val = fuel_rate or 0
    engine_load_val = engine_load or 0
    coolant_temp_val = coolant_temp or 0  # Â°F
    pwr_ext_val = pwr_ext or 0
    speed_val = speed or 0

    # Engine ON detection - RPM is primary indicator
    # Secondary indicators only valid if they show ACTIVE consumption/load
    # (coolant_temp alone is NOT reliable - stays hot after engine off)
    engine_running = (
        rpm_val > 0
        or fuel_rate_val > 0.5  # Active fuel consumption
        or (engine_load_val > 0 and coolant_temp_val > 120)  # Load + temp together
    )

    # If engine is running and speed is low/none = STOPPED (idling)
    if engine_running and speed_val < 2:
        return "STOPPED"

    # Moving - speed > 2 mph (filters GPS noise/drift)
    if speed_val > 2:
        return "MOVING"

    # No GPS data and no engine indicators = truly offline
    if speed is None and not engine_running:
        return "OFFLINE"

    # Engine OFF checks
    # Shore power connected (13.2V+ indicates external power)
    if pwr_ext_val > 13.2:
        return "PARKED"  # Plugged in, engine off

    # Battery voltage in normal range (12-13.2V) = recently used, parked
    if pwr_ext_val > 11.5:
        return "PARKED"  # Battery shows truck is connected and alive

    # Coolant temp between ambient and running = recently stopped
    if coolant_temp_val > 60 and coolant_temp_val <= 120:
        return "PARKED"  # Engine cooling down = recently parked

    # Data is fresh (<15 min) but no engine activity = parked
    if data_age_min < 5:
        return "PARKED"  # Very recent data, just no activity

    # Fallback - older data with no activity
    return "OFFLINE"


def calculate_consumption(
    speed: Optional[float],
    rpm: Optional[float],
    fuel_rate: Optional[float],
    total_fuel_used: Optional[float],
    estimator: FuelEstimator,
    dt_hours: float,
    truck_status: str,
) -> float:
    """
    Multi-source consumption calculation with intelligent fallback

    Priority:
    1. ECU cumulative counter (most accurate)
    2. fuel_rate sensor (if valid for current speed)
    3. Physics-based estimate
    """
    # Try ECU consumption first
    ecu_consumption = estimator.calculate_ecu_consumption(
        total_fuel_used, dt_hours, fuel_rate
    )
    if ecu_consumption is not None:
        return ecu_consumption

    # Validate fuel_rate sensor
    if fuel_rate is not None and fuel_rate > 0:
        # Determine minimum valid fuel_rate based on speed
        if speed is not None and speed > 40:
            min_lph = 8.0  # Highway minimum
        elif speed is not None and speed > 20:
            min_lph = 5.0  # City minimum
        elif speed is not None and speed > 5:
            min_lph = 3.0  # Low speed minimum
        else:
            min_lph = 1.5  # Idle minimum

        if fuel_rate >= min_lph:
            return fuel_rate

    # Physics-based fallback for Class 8 trucks (44k lbs loaded)
    if truck_status == "MOVING" and speed is not None and speed > 5:
        # ğŸ”§ FIX Dec 22: Realistic consumption for heavy trucks
        # Highway (60-75 mph): 35-50 L/h (9-13 gph) â†’ 4-7 MPG
        # City (20-40 mph): 25-35 L/h (6.5-9 gph) â†’ 3-5 MPG
        if speed >= 60:
            # Highway: base 20 L/h + speed factor
            return 20.0 + (speed * 0.35)  # ~44 L/h at 70 mph = 11.6 gph â†’ 6 MPG
        elif speed >= 40:
            # Mixed: base 15 L/h + speed factor
            return 15.0 + (speed * 0.30)  # ~27 L/h at 40 mph = 7.1 gph â†’ 5.6 MPG
        else:
            # City: base 12 L/h + speed factor
            return 12.0 + (speed * 0.25)  # ~18 L/h at 25 mph = 4.8 gph â†’ 5.2 MPG
    elif truck_status == "STOPPED":
        return 2.5  # Idle consumption
    else:
        return 0.0


def detect_refuel(
    sensor_pct: float,
    estimated_pct: float,
    last_sensor_pct: Optional[float],
    time_gap_hours: float,
    truck_status: str,
    tank_capacity_gal: float,
    truck_id: str = "",
) -> Optional[Dict]:
    """
    Gap-aware refuel detection using Kalman estimate as baseline.

    ğŸ”§ v3.12.29: Use Kalman estimate (estimated_pct) as "before" reference
    - The Kalman filter tracks expected fuel level based on consumption model
    - When sensor shows higher than Kalman after a gap â†’ refuel detected
    - This is more accurate than comparing two noisy sensor readings

    Criteria:
    - Time gap between 5 min and 24 hours (extended for overnight refuels)
    - Sensor > Kalman by > 15% (fuel was added)
    - Minimum 10 gallons added

    ğŸ”§ v3.15.4: Extended max gap from 2h to 24h to catch overnight refuels
    Many trucks refuel when offline (nights/weekends) and the 2h limit
    was causing missed detections (e.g., FF7702).

    The Kalman represents "what we expected" after consumption
    The Sensor represents "what's actually in the tank now"
    Difference = fuel added during the gap
    """
    if sensor_pct is None or estimated_pct is None:
        return None

    # ğŸ”§ FIX v5.6.1: Use configurable gap limit (was hardcoded 72h)
    MAX_GAP_HOURS = float(os.getenv("MAX_REFUEL_GAP_HOURS", "96"))  # 4 days default

    # Time gap validation (5 min to MAX_GAP_HOURS)
    # ğŸ”§ v3.15.4: Extended from 2h to 24h for overnight refuels
    # ğŸ”§ v5.5.3: Extended to 72h for weekend/holiday refuels (VD3579 missed refuel case)
    # ğŸ”§ v5.6.1: Extended to 96h (configurable) for JC1282 case
    if time_gap_hours < 5 / 60:
        return None
    if time_gap_hours > MAX_GAP_HOURS:
        # ğŸ”§ v5.5.3: Log when rejecting due to large gap (for debugging)
        fuel_jump = sensor_pct - estimated_pct
        if fuel_jump > 10:  # ğŸ”§ v5.6.1: Lowered from 15 for better logging
            logger.warning(
                f"â­ï¸ [{truck_id}] Potential refuel REJECTED: gap={time_gap_hours:.1f}h > {MAX_GAP_HOURS}h max, "
                f"jump={fuel_jump:.1f}% ({(fuel_jump/100)*tank_capacity_gal:.1f} gal)"
            )
        return None

    # ğŸ”§ v3.12.29: Calculate increase using Kalman as baseline
    # fuel_increase = current_sensor - kalman_estimate (what we expected)
    fuel_increase_pct = sensor_pct - estimated_pct

    # ğŸ”§ FIX v5.19.1: ALSO check sensor-to-sensor comparison as fallback
    # Sometimes Kalman is wrong (drift, bad calibration) and misses obvious refuels
    # Use BOTH methods and take the one that shows a refuel
    sensor_to_sensor_jump = None
    if last_sensor_pct is not None:
        sensor_to_sensor_jump = sensor_pct - last_sensor_pct

    # ğŸ”§ FIX v5.6.1: Use settings instead of hardcoded values
    # This allows runtime configuration via environment variables
    from settings import get_settings

    _settings = get_settings()

    # ğŸ†• v3.12.32 QUICK WIN #1: Adaptive Refuel Thresholds
    # Learn optimal thresholds per truck based on confirmed refuel history
    adaptive = get_adaptive_thresholds()
    min_increase_pct, min_increase_gal = adaptive.get_thresholds(truck_id)

    # Fallback to settings if adaptive returns None
    if min_increase_pct is None or min_increase_gal is None:
        container = get_container()
        min_increase_pct = (
            container.settings.fuel.min_refuel_jump_pct
        )  # Default 10.0 (was 15.0)
        min_increase_gal = (
            container.settings.fuel.min_refuel_gallons
        )  # Default 5.0 (was 10.0)

    # ğŸ”§ v3.12.28: Apply refuel_factor for sensor calibration
    refuel_factor = get_refuel_factor(truck_id)
    increase_gal_raw = (fuel_increase_pct / 100) * tank_capacity_gal
    increase_gal = increase_gal_raw * refuel_factor

    # ğŸ”§ v5.19.1: DUAL DETECTION - use EITHER Kalman OR sensor-to-sensor
    # This catches refuels that Kalman misses due to drift/calibration issues
    kalman_method_triggered = (
        fuel_increase_pct >= min_increase_pct and increase_gal >= min_increase_gal
    )

    sensor_method_triggered = False
    sensor_increase_gal = 0
    if sensor_to_sensor_jump is not None:
        sensor_increase_gal = (
            (sensor_to_sensor_jump / 100) * tank_capacity_gal * refuel_factor
        )
        sensor_method_triggered = (
            sensor_to_sensor_jump >= min_increase_pct
            and sensor_increase_gal >= min_increase_gal
        )

    # Use whichever method shows larger refuel (more conservative)
    if kalman_method_triggered or sensor_method_triggered:
        # Pick the method that shows LARGER refuel (more accurate)
        if sensor_method_triggered and sensor_increase_gal > increase_gal:
            fuel_increase_pct = sensor_to_sensor_jump
            increase_gal = sensor_increase_gal
            detection_method = "SENSOR"
            baseline_pct = last_sensor_pct
        else:
            detection_method = "KALMAN"
            baseline_pct = estimated_pct
            baseline_pct = estimated_pct

        # Extra safety: reject small jumps when tank is already nearly full
        # (likely sensor noise, not actual refuel)
        # ğŸ”§ v3.15.3: Allow refuels >25 gal even near full tank (FF7702 case)
        # ğŸ”§ FIX v5.6.1: Reduced from 25â†’15 gal threshold (JC1282 case)
        # ğŸ”§ FIX v5.19.1: Reduced to 10 gal - catch smaller partial refuels
        # Now: reject only if BOTH <8% AND <10 gal (was <10% AND <15 gal)
        if sensor_pct > 95 and fuel_increase_pct < 8 and increase_gal < 10:
            logger.debug(
                f"â­ï¸ [{truck_id}] Skipping tiny near-full jump: +{fuel_increase_pct:.1f}% +{increase_gal:.1f}gal"
            )
            return None

        factor_note = f" (factor={refuel_factor})" if refuel_factor != 1.0 else ""
        logger.info(
            f"â›½ [{truck_id}] REFUEL DETECTED ({detection_method}): "
            f"Baseline={baseline_pct:.1f}% â†’ Sensor={sensor_pct:.1f}% "
            f"(+{fuel_increase_pct:.1f}%, +{increase_gal:.1f} gal{factor_note}) "
            f"over {time_gap_hours*60:.0f} min gap"
        )

        # ğŸ”§ v5.5.3: Calculate display values that are CONSISTENT
        # prev_pct for display = current_sensor - increase_pct (so math adds up)
        # This ensures: after - before = gallons_added (user-visible consistency)
        display_before_pct = sensor_pct - fuel_increase_pct
        display_gallons = (fuel_increase_pct / 100) * tank_capacity_gal * refuel_factor

        return {
            "type": "REFUEL",
            "prev_pct": display_before_pct,  # ğŸ”§ v5.5.3: Consistent with gallons shown
            "new_pct": sensor_pct,
            "increase_pct": fuel_increase_pct,
            "increase_gal": display_gallons,  # ğŸ”§ v5.5.3: Recalculated for consistency
            "time_gap_hours": time_gap_hours,
            "kalman_before": estimated_pct,  # Original Kalman for debugging
            "last_sensor_pct": last_sensor_pct,  # Last sensor reading for reference
            "detection_method": detection_method,  # ğŸ†• v5.19.1: Track which method triggered
        }
    else:
        # ğŸ†• v5.19.1: Log near-misses for debugging
        if fuel_increase_pct > 5 or (
            sensor_to_sensor_jump and sensor_to_sensor_jump > 5
        ):
            sensor_jump_str = (
                f"+{sensor_to_sensor_jump:.1f}%" if sensor_to_sensor_jump else "N/A"
            )
            sensor_gal_str = (
                f"({sensor_increase_gal:.1f} gal)"
                if sensor_increase_gal is not None
                else "(N/A)"
            )
            logger.debug(
                f"â­ï¸ [{truck_id}] Near-miss refuel: "
                f"Kalman: +{fuel_increase_pct:.1f}% ({increase_gal:.1f} gal), "
                f"Sensor: {sensor_jump_str} {sensor_gal_str} "
                f"- Below threshold (need {min_increase_pct}% AND {min_increase_gal} gal)"
            )

    return None


def detect_multiple_refuels(
    fuel_history: List[Dict],
    estimator,
    tank_capacity_gal: float,
    truck_id: str = "",
) -> List[Dict]:
    """
    ğŸ†• v5.12.0: Detect ALL refuels in a time series of fuel readings.

    This fixes the issue where only ONE refuel per sync cycle was detected,
    causing missed events when trucks refuel multiple times per day.

    Args:
        fuel_history: List of dicts with keys: timestamp, fuel_pct, epoch_time
                      Must be sorted chronologically (oldest first)
        estimator: FuelEstimator instance for Kalman baseline
        tank_capacity_gal: Tank capacity in gallons
        truck_id: Truck identifier for logging

    Returns:
        List of refuel events (same format as detect_refuel)

    Example:
        PC1280 on Dec 17, 2025:
        - 02:49: 6% â†’ 65% (+58 gal) - First refuel
        - 22:25: 44% â†’ 100% (+56 gal) - Second refuel
        Old code: Detected only first one
        New code: Detects both
    """
    if len(fuel_history) < 2:
        return []

    refuels_detected = []

    # Process each pair of consecutive readings
    for i in range(1, len(fuel_history)):
        prev_reading = fuel_history[i - 1]
        curr_reading = fuel_history[i]

        prev_pct = prev_reading.get("fuel_pct")
        curr_pct = curr_reading.get("fuel_pct")
        prev_time = prev_reading.get("timestamp")
        curr_time = curr_reading.get("timestamp")

        if None in (prev_pct, curr_pct, prev_time, curr_time):
            continue

        # Calculate time gap
        time_delta = curr_time - prev_time
        time_gap_hours = time_delta.total_seconds() / 3600

        # Use Kalman estimate as baseline (what we expected after consumption)
        # For historical processing, we need to "rewind" Kalman to prev_time
        # For simplicity, we'll use prev_pct as baseline (sensor-to-sensor comparison)
        # This is slightly less accurate than Kalman but works for multi-refuel detection

        # Call the standard refuel detector
        refuel_event = detect_refuel(
            sensor_pct=curr_pct,
            estimated_pct=prev_pct,  # Use previous sensor reading as baseline
            last_sensor_pct=prev_pct,
            time_gap_hours=time_gap_hours,
            truck_status="UNKNOWN",  # Not critical for detection
            tank_capacity_gal=tank_capacity_gal,
            truck_id=truck_id,
        )

        if refuel_event:
            # Add timestamp to refuel event
            refuel_event["timestamp"] = curr_time
            refuels_detected.append(refuel_event)
            logger.info(
                f"ğŸš° [MULTI-REFUEL] {truck_id} @ {curr_time}: "
                f"{prev_pct:.1f}% â†’ {curr_pct:.1f}% (+{refuel_event['increase_gal']:.1f} gal)"
            )

    return refuels_detected


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ENHANCED THEFT DETECTION v5.8.0
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


def get_time_of_day_factor(timestamp: Optional[datetime] = None) -> Tuple[float, str]:
    """
    ğŸ†• v5.8.0: Get theft confidence multiplier based on time of day.

    Night (10PM - 5AM): 1.3x (more suspicious)
    Weekend night: 1.4x (most suspicious)
    Business hours: 0.8x (less suspicious - more witnesses)
    Weekend day: 1.0x (neutral)

    Returns:
        Tuple of (factor, description)
    """
    if timestamp is None:
        timestamp = datetime.now(timezone.utc)

    hour = timestamp.hour
    weekday = timestamp.weekday()  # 0=Monday, 6=Sunday
    is_weekend = weekday >= 5

    # Night hours (10 PM - 5 AM)
    is_night = hour >= 22 or hour <= 5

    if is_night:
        if is_weekend:
            return (1.4, "WEEKEND_NIGHT")
        return (1.3, "NIGHT")

    # Business hours (8 AM - 6 PM)
    is_business = 8 <= hour <= 18

    if is_business and not is_weekend:
        return (0.8, "BUSINESS_HOURS")

    if is_weekend:
        return (1.0, "WEEKEND_DAY")

    return (1.0, "EVENING")


def get_sensor_health_factor(
    voltage: Optional[float] = None,
    gps_quality: Optional[str] = None,
    sats: Optional[int] = None,
) -> Tuple[float, str, List[str]]:
    """
    ğŸ†• v5.8.0: Check sensor health to distinguish theft vs sensor failure.

    Signs of sensor failure (NOT theft):
    - Low voltage (< 12V) - battery issues affect sensor accuracy
    - Poor GPS (< 4 satellites) - location/data transmission issues
    - Very poor GPS quality string

    Returns:
        Tuple of (factor, status, issues_list)
        - factor: 0.3-1.0 (lower = probably sensor issue, not theft)
        - status: HEALTHY, DEGRADED, FAILING, UNKNOWN
        - issues: List of detected issues
    """
    issues = []
    factor = 1.0
    status = "HEALTHY"

    # Check voltage
    if voltage is not None:
        if voltage < 11.5:
            issues.append(f"Critical voltage: {voltage:.1f}V")
            factor *= 0.3
            status = "FAILING"
        elif voltage < 12.5:
            issues.append(f"Low voltage: {voltage:.1f}V")
            factor *= 0.6
            if status == "HEALTHY":
                status = "DEGRADED"

    # Check GPS satellites
    if sats is not None:
        if sats < 3:
            issues.append(f"Very poor GPS: {sats} sats")
            factor *= 0.4
            status = "FAILING"
        elif sats < 5:
            issues.append(f"Weak GPS: {sats} sats")
            factor *= 0.7
            if status == "HEALTHY":
                status = "DEGRADED"

    # Check GPS quality string
    if gps_quality is not None:
        quality_lower = gps_quality.lower()
        if "poor" in quality_lower or "none" in quality_lower:
            issues.append(f"GPS quality: {gps_quality}")
            factor *= 0.5
            if status == "HEALTHY":
                status = "DEGRADED"

    if not issues:
        return (1.0, "HEALTHY", [])

    return (max(0.3, factor), status, issues)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ†• v5.8.1: GEOFENCE SAFE-ZONE DETECTION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Safe zones configuration - drops inside these zones are less suspicious
# Includes gas stations, depots, maintenance yards, etc.
SAFE_ZONES = {
    "DEPOT_MIAMI": {
        "name": "Miami Main Depot",
        "type": "CIRCLE",
        "lat": 25.7617,
        "lon": -80.1918,
        "radius_miles": 0.5,
        "trust_level": 0.3,  # Factor applied when in zone (0.3 = 70% reduction)
    },
    "GAS_STATION_SHELL_1": {
        "name": "Shell Gas Station I-95",
        "type": "CIRCLE",
        "lat": 25.8500,
        "lon": -80.2000,
        "radius_miles": 0.2,
        "trust_level": 0.4,  # Gas stations are trusted for refuels, less for drops
    },
    "DEPOT_ORLANDO": {
        "name": "Orlando Distribution Center",
        "type": "CIRCLE",
        "lat": 28.5383,
        "lon": -81.3792,
        "radius_miles": 0.5,
        "trust_level": 0.3,
    },
    "DEPOT_JACKSONVILLE": {
        "name": "Jacksonville Hub",
        "type": "CIRCLE",
        "lat": 30.3322,
        "lon": -81.6557,
        "radius_miles": 0.5,
        "trust_level": 0.3,
    },
    "MAINTENANCE_YARD": {
        "name": "Maintenance Yard",
        "type": "CIRCLE",
        "lat": 25.7900,
        "lon": -80.2100,
        "radius_miles": 0.3,
        "trust_level": 0.2,  # Very trusted - fuel transfers happen here
    },
}


def check_safe_zone(
    latitude: float, longitude: float, zones: Optional[Dict] = None
) -> Tuple[bool, float, Optional[Dict]]:
    """
    ğŸ†• v5.8.1: Check if coordinates are within a safe zone.

    Safe zones are trusted locations where fuel drops are less suspicious:
    - Depots (authorized fuel transfers)
    - Gas stations (authorized refueling, tank calibration)
    - Maintenance yards (authorized maintenance)

    Args:
        latitude: GPS latitude
        longitude: GPS longitude
        zones: Optional custom zones dict (uses SAFE_ZONES if not provided)

    Returns:
        Tuple of:
        - in_safe_zone: True if in any safe zone
        - trust_factor: Multiplier for theft confidence (lower = more trusted)
        - zone_info: Details of the zone if inside one, None otherwise
    """
    if zones is None:
        zones = SAFE_ZONES

    if latitude is None or longitude is None:
        return (False, 1.0, None)

    for zone_id, zone in zones.items():
        if zone.get("type") == "CIRCLE":
            distance = haversine_distance(latitude, longitude, zone["lat"], zone["lon"])

            if distance <= zone.get("radius_miles", 0.5):
                return (
                    True,
                    zone.get("trust_level", 0.5),
                    {
                        "zone_id": zone_id,
                        "zone_name": zone["name"],
                        "distance_miles": round(distance, 3),
                        "trust_level": zone.get("trust_level", 0.5),
                    },
                )

    return (False, 1.0, None)


def detect_fuel_theft(
    sensor_pct: float,
    estimated_pct: float,
    last_sensor_pct: Optional[float],
    truck_status: str,
    time_gap_hours: float,
    tank_capacity_gal: float = 200.0,
    # ğŸ†• v5.8.0: New optional parameters for enhanced detection
    timestamp: Optional[datetime] = None,
    voltage: Optional[float] = None,
    gps_quality: Optional[str] = None,
    sats: Optional[int] = None,
    latitude: Optional[float] = None,
    longitude: Optional[float] = None,
    # ğŸ†• v5.18.0: Speed gating parameter
    speed_mph: Optional[float] = None,
) -> Optional[Dict]:
    """
    ğŸ†• v5.18.0: Enhanced Fuel theft detection with speed gating (80% FP reduction).
    ğŸ†• v5.8.0: Enhanced Fuel theft detection with multi-factor analysis.

    Detection criteria (ANY match triggers alert):
    1. STOPPED theft: Large drop (>10%) while truck was stopped
    2. RAPID theft: Very large drop (>20%) in short time (<1 hour)
    3. PATTERN theft: Multiple moderate drops (>5%) when consumption doesn't explain it

    ğŸ†• v5.18.0 CRITICAL Enhancement:
    0. SPEED GATING: If truck moving >3 mph â†’ 99.9% normal consumption (not theft)
       This single check eliminates ~80% of false positives instantly

    ğŸ†• v5.8.0 Enhancements:
    4. TIME-OF-DAY: Night/weekend drops are more suspicious
    5. SENSOR HEALTH: Low voltage/GPS issues reduce confidence (likely sensor, not theft)
    6. GEOFENCE-READY: lat/lon passed for future safe-zone detection

    Args:
        sensor_pct: Current sensor reading (%)
        estimated_pct: Expected level based on consumption model
        last_sensor_pct: Previous sensor reading (%)
        truck_status: MOVING, STOPPED, or IDLE
        time_gap_hours: Time since last reading
        tank_capacity_gal: Tank capacity for gallon calculations
        timestamp: Event timestamp (for time-of-day analysis)
        voltage: Battery voltage (for sensor health)
        gps_quality: GPS quality string (for sensor health)
        sats: Number of GPS satellites (for sensor health)
        latitude: GPS latitude (for future geofence)
        longitude: GPS longitude (for future geofence)
        speed_mph: GPS speed in mph (for speed gating)

    Returns:
        Dict with theft details or None if no theft detected
    """
    if last_sensor_pct is None or sensor_pct is None:
        return None

    # ğŸš€ FASE 2.1: SPEED GATING - 80% FP REDUCTION (HIGHEST PRIORITY CHECK)
    # If truck is moving >3 mph, fuel drop is 99.9% consumption, not theft
    # This single check eliminates ~80% of false positives instantly
    if speed_mph is not None and speed_mph > 3.0:
        return None  # Truck en movimiento = consumo normal

    fuel_drop_pct = last_sensor_pct - sensor_pct
    fuel_drop_gal = fuel_drop_pct * tank_capacity_gal / 100

    # No significant drop
    if fuel_drop_pct <= 3:
        return None

    # Base confidence calculation
    base_confidence = 0.0
    theft_type = None
    reasons = []
    adjustments = []

    # 1. STOPPED theft: Drop while truck was stationary
    if truck_status == "STOPPED":
        if fuel_drop_pct > 10:
            base_confidence = 0.9
            theft_type = "STOPPED_THEFT"
            reasons.append(f"Large drop ({fuel_drop_pct:.1f}%) while stopped")
        elif fuel_drop_pct > 5:
            base_confidence = 0.6
            theft_type = "STOPPED_SUSPICIOUS"
            reasons.append(f"Moderate drop ({fuel_drop_pct:.1f}%) while stopped")

    # 2. RAPID theft: Very large drop in short time
    if fuel_drop_pct > 20 and time_gap_hours < 1.0:
        if base_confidence < 0.85:
            base_confidence = 0.85
            theft_type = "RAPID_LOSS"
            reasons.append(
                f"Rapid loss ({fuel_drop_pct:.1f}%) in {time_gap_hours*60:.0f} min"
            )

    # 3. UNEXPLAINED: Drop much larger than expected consumption
    if estimated_pct is not None:
        expected_drop = last_sensor_pct - estimated_pct
        unexplained_drop = (
            fuel_drop_pct - expected_drop if expected_drop > 0 else fuel_drop_pct
        )

        if unexplained_drop > 8:
            if base_confidence < 0.7:
                base_confidence = 0.7
                theft_type = "UNEXPLAINED_LOSS"
            reasons.append(f"Unexplained loss of {unexplained_drop:.1f}%")

    # 4. IDLE theft: Drop while engine running but not moving
    if truck_status == "IDLE" and fuel_drop_pct > 8:
        if base_confidence < 0.65:
            base_confidence = 0.65
            theft_type = "IDLE_LOSS"
            reasons.append(f"Significant drop ({fuel_drop_pct:.1f}%) while idling")

    # If no base suspicion, exit early
    if base_confidence < 0.5:
        return None

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸ†• v5.8.0: APPLY ENHANCEMENT FACTORS
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    final_confidence = base_confidence

    # 5. TIME-OF-DAY FACTOR
    time_factor, time_period = get_time_of_day_factor(timestamp)
    if time_factor != 1.0:
        old_conf = final_confidence
        final_confidence = min(0.99, final_confidence * time_factor)
        if time_factor > 1.0:
            adjustments.append(f"Time ({time_period}): +{(time_factor-1)*100:.0f}%")
        else:
            adjustments.append(f"Time ({time_period}): {(time_factor-1)*100:.0f}%")

    # 6. SENSOR HEALTH FACTOR
    sensor_factor, sensor_status, sensor_issues = get_sensor_health_factor(
        voltage=voltage, gps_quality=gps_quality, sats=sats
    )
    if sensor_factor < 1.0:
        old_conf = final_confidence
        final_confidence = final_confidence * sensor_factor
        adjustments.append(f"Sensor ({sensor_status}): {(sensor_factor-1)*100:.0f}%")
        for issue in sensor_issues:
            reasons.append(f"âš ï¸ {issue}")

    # 7. GEOFENCE / SAFE-ZONE FACTOR
    # ğŸ†• v5.8.1: Check if truck is in a trusted safe zone
    geofence_info = None
    if latitude is not None and longitude is not None:
        in_safe_zone, safe_zone_factor, zone_details = check_safe_zone(
            latitude, longitude
        )

        geofence_info = {
            "lat": latitude,
            "lon": longitude,
            "in_safe_zone": in_safe_zone,
            "zone": zone_details,
        }

        if in_safe_zone and zone_details:
            old_conf = final_confidence
            final_confidence = final_confidence * safe_zone_factor
            adjustments.append(
                f"SafeZone ({zone_details['zone_name']}): {(safe_zone_factor-1)*100:.0f}%"
            )
            reasons.append(
                f"ğŸ“ In trusted zone: {zone_details['zone_name']} "
                f"({zone_details['distance_miles']:.2f} mi from center)"
            )

    # Final threshold check
    if final_confidence >= 0.5:
        # Generate recommendation based on final confidence
        if final_confidence >= 0.85:
            recommendation = "ğŸš¨ HIGH PRIORITY: Investigate immediately"
        elif final_confidence >= 0.7:
            recommendation = "âš ï¸ MEDIUM: Investigate within 24 hours"
        else:
            recommendation = "ğŸ“‹ LOW: Monitor and review patterns"

        logger.warning(
            f"ğŸš¨ POSSIBLE FUEL THEFT ({theft_type}): -{fuel_drop_pct:.1f}% "
            f"({fuel_drop_gal:.1f} gal) while {truck_status} for {time_gap_hours*60:.0f} min. "
            f"Base: {base_confidence:.0%} â†’ Final: {final_confidence:.0%} "
            f"[{', '.join(adjustments) if adjustments else 'no adjustments'}]"
        )

        return {
            "type": theft_type,
            "drop_pct": fuel_drop_pct,
            "drop_gal": fuel_drop_gal,
            "time_gap_hours": time_gap_hours,
            "base_confidence": base_confidence,
            "confidence": final_confidence,  # Final adjusted confidence
            "reasons": reasons,
            "adjustments": adjustments,
            "truck_status": truck_status,
            "time_period": time_period,
            "sensor_status": sensor_status,
            "geofence": geofence_info,
            "recommendation": recommendation,
        }

    return None


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# REFUEL PERSISTENCE & NOTIFICATIONS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Cooldown tracker to avoid duplicate notifications
_refuel_notification_cooldown: Dict[str, datetime] = {}

# ğŸ†• v3.12.20: Pending refuels buffer for consecutive jump consolidation
# When refueling, sensor may report: 10% â†’ 40% â†’ 80% â†’ 100% in quick succession
# This buffer accumulates all jumps and saves/notifies as ONE event
_pending_refuels: Dict[str, Dict] = {}
CONSECUTIVE_REFUEL_WINDOW_MINUTES = 10  # Jumps within 10 min = same refuel event


def add_pending_refuel(
    truck_id: str,
    gallons: float,
    before_pct: float,
    after_pct: float,
    timestamp: datetime,
) -> Optional[Dict]:
    """
    ğŸ†• v3.12.20: Buffer consecutive refuel jumps into single event.

    When a truck refuels, the sensor may report multiple jumps:
    - Jump 1: 10% â†’ 40% (+30%)
    - Jump 2: 40% â†’ 80% (+40%)  â† within 10 min = same refuel event
    - Jump 3: 80% â†’ 100% (+20%) â† within 10 min = same refuel event

    This accumulates all jumps. Returns finalized event when window expires.
    """
    global _pending_refuels

    now = datetime.now(timezone.utc)

    if truck_id in _pending_refuels:
        pending = _pending_refuels[truck_id]
        time_since_last = (now - pending["last_jump_time"]).total_seconds() / 60

        if time_since_last <= CONSECUTIVE_REFUEL_WINDOW_MINUTES:
            # Within window - accumulate
            pending["gallons"] += gallons
            pending["end_pct"] = after_pct
            pending["last_jump_time"] = now
            logger.info(
                f"[{truck_id}] ğŸ“Š Consecutive refuel jump: +{gallons:.1f} gal "
                f"(total: {pending['gallons']:.1f} gal, {pending['start_pct']:.1f}% â†’ {after_pct:.1f}%)"
            )
            return None
        else:
            # Window expired - finalize previous, start new
            finalized = finalize_pending_refuel(truck_id)

            _pending_refuels[truck_id] = {
                "start_pct": before_pct,
                "end_pct": after_pct,
                "gallons": gallons,
                "start_time": timestamp,
                "last_jump_time": now,
            }
            return finalized
    else:
        # Start new pending refuel
        _pending_refuels[truck_id] = {
            "start_pct": before_pct,
            "end_pct": after_pct,
            "gallons": gallons,
            "start_time": timestamp,
            "last_jump_time": now,
        }
        return None


def finalize_pending_refuel(truck_id: str) -> Optional[Dict]:
    """
    ğŸ†• v3.12.20: Finalize a pending refuel - returns data for DB save & notification.
    """
    global _pending_refuels

    if truck_id not in _pending_refuels:
        return None

    pending = _pending_refuels.pop(truck_id)

    return {
        "truck_id": truck_id,
        "gallons": pending["gallons"],
        "start_pct": pending["start_pct"],
        "end_pct": pending["end_pct"],
        "timestamp": pending["start_time"],
    }


def flush_stale_pending_refuels(max_age_minutes: int = 15) -> List[Dict]:
    """
    ğŸ†• v3.12.20: Finalize any pending refuels older than max_age_minutes.
    Call periodically to ensure refuels don't stay buffered forever.
    """
    global _pending_refuels

    now = datetime.now(timezone.utc)
    stale_trucks = []
    finalized = []

    for truck_id, pending in _pending_refuels.items():
        age_minutes = (now - pending["last_jump_time"]).total_seconds() / 60
        if age_minutes > max_age_minutes:
            stale_trucks.append(truck_id)

    for truck_id in stale_trucks:
        result = finalize_pending_refuel(truck_id)
        if result:
            finalized.append(result)
            logger.info(
                f"[{truck_id}] âœ… Flushed pending refuel: +{result['gallons']:.1f} gal"
            )

    return finalized


def save_refuel_event(
    connection,
    truck_id: str,
    timestamp_utc: datetime,
    fuel_before: float,
    fuel_after: float,
    gallons_added: float,
    latitude: Optional[float] = None,
    longitude: Optional[float] = None,
    refuel_type: str = "NORMAL",
) -> bool:
    """
    Save refuel event to refuel_events table.

    ğŸ”§ v3.12.28: Added duplicate check to prevent double inserts.
    Checks for existing refuel within 5-minute window for same truck.

    Returns True if successfully inserted, False if duplicate or error.
    """
    try:
        with connection.cursor() as cursor:
            # ğŸ”§ v3.12.30: Check for duplicate refuel using fuel_after percentage
            # ğŸ”§ DEC 23 FIX (BUG-005): Relaxed duplicate check
            # - Reduced time window from 5min to 2min
            # - Compare gallons_added instead of fuel_after % (more tolerant of sensor drift)
            # - Increased tolerance from 2% to 5 gallons
            check_query = """
                SELECT id, gallons_added FROM refuel_events 
                WHERE truck_id = %s 
                  AND timestamp_utc BETWEEN %s - INTERVAL 2 MINUTE AND %s + INTERVAL 2 MINUTE
                  AND ABS(gallons_added - %s) < 5
                LIMIT 1
            """
            cursor.execute(
                check_query, (truck_id, timestamp_utc, timestamp_utc, gallons_added)
            )
            existing = cursor.fetchone()

            if existing:
                logger.info(
                    f"â­ï¸ Duplicate refuel skipped: {truck_id} +{gallons_added:.1f} gal "
                    f"(existing: +{existing['gallons_added']:.1f} gal at {fuel_after:.1f}%)"
                )
                return False

            # Insert new refuel event
            query = """
                INSERT INTO refuel_events 
                (refuel_time, truck_id, carrier_id, before_pct, after_pct, 
                 gallons_added, refuel_type, latitude, longitude, confidence, validated)
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
            """
            cursor.execute(
                query,
                (
                    timestamp_utc,
                    truck_id,
                    "skylord",
                    fuel_before,
                    fuel_after,
                    gallons_added,
                    refuel_type,
                    latitude,
                    longitude,
                    0.9,  # High confidence for detected refuels
                    0,  # Not validated yet
                ),
            )
            connection.commit()
            logger.info(f"ğŸ’¾ Refuel saved to DB: {truck_id} +{gallons_added:.1f} gal")
            return True
    except Exception as e:
        logger.error(f"âŒ Failed to save refuel to DB for {truck_id}: {e}")
        return False


def send_refuel_notification(
    truck_id: str,
    gallons_added: float,
    fuel_before: float,
    fuel_after: float,
    timestamp_utc: datetime,
) -> bool:
    """
    Send SMS and Email notification for refuel event.

    Uses environment variables for configuration:
    - TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN, TWILIO_FROM_NUMBER, TWILIO_TO_NUMBERS
    - SMTP_SERVER, SMTP_PORT, SMTP_USER, SMTP_PASS, ALERT_TO/ALERT_EMAIL_TO

    Enforces 30 minute cooldown per truck to avoid spam.
    """
    global _refuel_notification_cooldown

    # Check cooldown (30 minutes)
    now = datetime.now(timezone.utc)
    last_notification = _refuel_notification_cooldown.get(truck_id)
    if last_notification:
        minutes_since = (now - last_notification).total_seconds() / 60
        if minutes_since < 30:
            logger.info(
                f"â³ Notification cooldown active for {truck_id} ({minutes_since:.1f} min ago)"
            )
            return False

    message = (
        f"â›½ REFUEL DETECTED\n"
        f"Truck: {truck_id}\n"
        f"Added: +{gallons_added:.1f} gal\n"
        f"Before: {fuel_before:.1f}% â†’ After: {fuel_after:.1f}%\n"
        f"Time: {timestamp_utc.strftime('%Y-%m-%d %H:%M UTC')}"
    )

    success = False

    # Try SMS via Twilio
    try:
        account_sid = os.getenv("TWILIO_ACCOUNT_SID")
        auth_token = os.getenv("TWILIO_AUTH_TOKEN")
        from_number = os.getenv("TWILIO_FROM_NUMBER")
        to_numbers = os.getenv("TWILIO_TO_NUMBERS", "")

        if account_sid and auth_token and from_number and to_numbers:
            from twilio.rest import Client

            client = Client(account_sid, auth_token)

            for to_number in to_numbers.split(","):
                to_number = to_number.strip()
                if to_number:
                    try:
                        client.messages.create(
                            body=message, from_=from_number, to=to_number
                        )
                        logger.info(f"ğŸ“± SMS sent to {to_number} for {truck_id} refuel")
                        success = True
                    except Exception as sms_err:
                        logger.error(f"âŒ SMS failed to {to_number}: {sms_err}")
        else:
            logger.debug("ğŸ“± SMS not configured (missing Twilio env vars)")
    except ImportError:
        logger.warning("ğŸ“± Twilio library not installed - SMS disabled")
    except Exception as e:
        logger.error(f"âŒ SMS notification error: {e}")

    # Try Email via SMTP
    try:
        import smtplib
        from email.message import EmailMessage

        smtp_server = os.getenv("SMTP_SERVER", "smtp.gmail.com")
        smtp_port = int(os.getenv("SMTP_PORT", "587"))
        smtp_user = os.getenv("SMTP_USER")
        smtp_pass = os.getenv("SMTP_PASS")
        # Support both variable names
        alert_to = os.getenv("ALERT_TO") or os.getenv("ALERT_EMAIL_TO")

        if smtp_user and smtp_pass and alert_to:
            msg = EmailMessage()
            msg["From"] = smtp_user
            msg["To"] = alert_to
            msg["Subject"] = f"â›½ Refuel Detected: {truck_id} +{gallons_added:.1f} gal"
            msg.set_content(message)

            with smtplib.SMTP(smtp_server, smtp_port, timeout=10) as server:
                server.starttls()
                server.login(smtp_user, smtp_pass)
                server.send_message(msg)

            logger.info(f"ğŸ“§ Email sent to {alert_to} for {truck_id} refuel")
            success = True
        else:
            logger.debug("ğŸ“§ Email not configured (missing SMTP env vars)")
    except Exception as e:
        logger.error(f"âŒ Email notification error: {e}")

    # Update cooldown if any notification succeeded
    if success:
        _refuel_notification_cooldown[truck_id] = now

    return success


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MAIN PROCESSING FUNCTION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


def process_truck(
    truck_id: str,
    sensor_data: Dict,
    state_manager: StateManager,
    mpg_config: MPGConfig,
    idle_config: IdleConfig,
) -> Dict:
    """
    Full processing pipeline for a single truck

    Steps:
    1. Extract sensor values
    2. Determine truck status
    3. Calculate time delta
    4. Check emergency reset
    5. Calculate consumption
    6. Run Kalman predict/update
    7. Check for refuels
    8. Update MPG tracking
    9. Calculate idle consumption
    10. Return complete metrics
    """
    # Get estimator and states
    estimator = state_manager.get_estimator(truck_id)
    mpg_state = state_manager.get_mpg_state(truck_id)
    anchor_detector = state_manager.get_anchor_detector(truck_id)

    # Tank capacity
    tank_capacity_gal = TANK_CAPACITIES.get(truck_id, TANK_CAPACITIES["default"])
    tank_capacity_liters = tank_capacity_gal * 3.78541

    # Extract sensor values
    timestamp = sensor_data.get("timestamp", datetime.now(timezone.utc))
    if timestamp.tzinfo is None:
        timestamp = timestamp.replace(tzinfo=timezone.utc)

    speed = sensor_data.get("speed")  # mph
    rpm = sensor_data.get("rpm")
    fuel_lvl = sensor_data.get("fuel_lvl")  # Percentage
    fuel_rate = sensor_data.get("fuel_rate")  # L/h
    odometer = sensor_data.get("odometer")  # âœ… FIXED Dec 22: odometer not odometer_mi
    altitude = sensor_data.get("altitude")  # feet
    latitude = sensor_data.get("latitude")
    longitude = sensor_data.get("longitude")
    engine_hours = sensor_data.get("engine_hours")
    hdop = sensor_data.get("hdop")
    coolant_temp = sensor_data.get("coolant_temp")
    total_fuel_used = sensor_data.get(
        "total_fuel_used"
    )  # âš ï¸ RAW value from ECU - will be converted later
    pwr_ext = sensor_data.get("pwr_ext")  # Battery voltage (V)
    engine_load = sensor_data.get("engine_load")  # Engine load %
    # ğŸ†• v3.12.26: Engine Health sensors
    oil_press = sensor_data.get("oil_press")  # Oil Pressure (psi)
    oil_temp = sensor_data.get("oil_temp")  # Oil Temperature (Â°F)
    def_level = sensor_data.get("def_level")  # DEF Level (%)
    intake_air_temp = sensor_data.get("intake_air_temp")  # Intake Air Temp (Â°F)
    # ğŸ†• v5.3.3: Ambient temperature for weather-adjusted alerts
    ambient_temp = sensor_data.get("ambient_temp")  # Outside Air Temp (Â°F)
    # ğŸ†• v5.12.2: Additional temperature sensors for predictive maintenance
    trans_temp = sensor_data.get("trans_temp")  # Transmission Oil Temp (Â°F)
    fuel_temp = sensor_data.get("fuel_temp")  # Fuel Temperature (Â°F)
    intercooler_temp = sensor_data.get("intercooler_temp")  # Intercooler Temp (Â°F)
    # ğŸ†• v5.12.2: Intake pressure for turbo monitoring
    intake_press = sensor_data.get("intake_press")  # Intake Manifold Pressure (kPa)
    # ğŸ†• v5.12.2: Retarder status for brake wear analysis
    retarder = sensor_data.get("retarder")  # Retarder level/status
    # ğŸ†• v5.3.3: ECU idle fuel counter (most accurate idle measurement)
    total_idle_fuel_raw = sensor_data.get(
        "total_idle_fuel"
    )  # âš ï¸ Comes in LITERS from ECU
    # ğŸ†• v3.12.28: New sensors for GPS quality and voltage monitoring
    sats = sensor_data.get("sats")  # GPS satellites count
    pwr_int = sensor_data.get("pwr_int")  # Internal voltage (battery)

    # ğŸ”§ CRITICAL FIX DEC 25 2025: Convert ECU fuel counters from LITERS to GALLONS
    # ECU sensors (total_fuel_used, total_idle_fuel) report in LITERS, not gallons
    # This was causing MPG to be inflated ~40-50% and idle to be ~75% too low
    LITERS_PER_GALLON = 3.78541

    # Convert total_idle_fuel from liters to gallons
    if total_idle_fuel_raw is not None and total_idle_fuel_raw > 0:
        # ğŸ”§ DEC 25 2025: Lowered threshold from 50k to 10k after finding real values ~8k-15k
        # Typical lifetime idle: 2,000-8,000 gal, or 7,500-30,000 L
        if total_idle_fuel_raw > 10000:  # If > 10k, it's definitely LITERS
            total_idle_fuel = total_idle_fuel_raw / LITERS_PER_GALLON
            logger.info(
                f"[{truck_id}] ğŸ”§ total_idle_fuel LITERSâ†’GAL: {total_idle_fuel_raw:.0f}L â†’ {total_idle_fuel:.0f}gal"
            )
        else:
            total_idle_fuel = total_idle_fuel_raw  # Assume gallons if < 10k
            logger.debug(
                f"[{truck_id}] total_idle_fuel assuming GALLONS: {total_idle_fuel:.2f}gal"
            )
    else:
        total_idle_fuel = None

    # ğŸ†• v5.7.3: Calculate descriptive GPS quality
    gps_quality_str = None
    if sats is not None:
        gps_result = analyze_gps_quality(satellites=sats, truck_id=truck_id)
        gps_quality_str = f"{gps_result.quality.value}|sats={sats}|acc={gps_result.estimated_accuracy_m:.0f}m"

    # Calculate data age
    now_utc = datetime.now(timezone.utc)
    data_age_min = (now_utc - timestamp).total_seconds() / 60.0

    # ğŸ†• BUG-008 FIX: Build sensor timestamp dict for validation
    # This allows determine_truck_status to check if sensors have similar timestamps
    sensor_timestamps = {
        "speed": int(data_age_min * 60),  # Convert back to seconds
        "rpm": int(data_age_min * 60),
        "fuel_rate": int(data_age_min * 60),
    }

    # Determine truck status (enhanced with multiple sensors + timestamp validation)
    truck_status = determine_truck_status(
        speed,
        rpm,
        fuel_rate,
        data_age_min,
        pwr_ext,
        engine_load,
        coolant_temp,
        sensor_timestamps=sensor_timestamps,  # ğŸ†• BUG-008: Pass timestamps for validation
    )

    # Calculate time delta from last update
    dt_hours = 0.0
    time_gap_hours = 0.0
    if estimator.last_update_time:
        time_gap_hours = (timestamp - estimator.last_update_time).total_seconds() / 3600
        dt_hours = min(time_gap_hours, 1.0)  # Cap at 1 hour for predictions

        # ğŸ”§ v5.8.2: Validate out-of-order data
        if time_gap_hours < -0.01:  # Allow small negative (clock skew)
            logger.warning(
                f"[{truck_id}] Out-of-order data detected: gap={time_gap_hours:.4f}h, skipping"
            )
            return None

    # Sensor percentage
    sensor_pct = fuel_lvl

    # ğŸ”§ DEC 23 FIX (BUG-002): Initialize odom_delta_mi at function start
    # This prevents "not associated with a value" error when truck is not MOVING
    odom_delta_mi = None

    # Initialize estimator if needed
    if not estimator.initialized and sensor_pct is not None:
        estimator.initialize(sensor_pct=sensor_pct)

    # ğŸ”§ DEC 28 FIX: Check for refuel BEFORE emergency reset
    # Emergency reset was destroying refuel evidence by resetting Kalman to sensor
    # before detect_refuel() could compare them
    early_refuel_detected = False
    if sensor_pct is not None and estimator.initialized:
        kalman_pct_before_reset = estimator.level_pct
        sensor_vs_kalman = sensor_pct - kalman_pct_before_reset

        # ğŸ”§ DEC 28 ENHANCEMENT: Use adaptive threshold per truck (learned from history)
        from adaptive_refuel_thresholds import get_adaptive_thresholds

        adaptive = get_adaptive_thresholds()
        min_increase_pct, _ = adaptive.get_thresholds(truck_id)
        early_refuel_threshold = (
            min_increase_pct if min_increase_pct else 15
        )  # Fallback to 15%

        # If there's a big jump after a gap, it's likely a refuel
        if (
            sensor_vs_kalman > early_refuel_threshold and time_gap_hours > 0.08
        ):  # 5 minutes
            early_refuel_detected = True
            logger.info(
                f"ğŸš° [EARLY-REFUEL-DETECTED] {truck_id}: kalman={kalman_pct_before_reset:.1f}% â†’ sensor={sensor_pct:.1f}% "
                f"(+{sensor_vs_kalman:.1f}%, threshold={early_refuel_threshold:.1f}%, gap={time_gap_hours:.1f}h)"
            )

    # Check emergency reset (high drift after long offline)
    # BUT skip if we detected a refuel - let the normal refuel handling process it
    if sensor_pct is not None and time_gap_hours > 2 and not early_refuel_detected:
        estimator.check_emergency_reset(sensor_pct, time_gap_hours, truck_status)

    # Calculate consumption
    consumption_lph = calculate_consumption(
        speed, rpm, fuel_rate, total_fuel_used, estimator, dt_hours, truck_status
    )

    # ğŸ†• v6.2.0: Validate ECU consumption against physics model
    # Detects faulty ECU sensors by comparing against calibrated model
    if (
        consumption_lph is not None
        and consumption_lph > 0
        and engine_load is not None
        and dt_hours > 0
        and dt_hours < 1.0
    ):
        # Calculate altitude change for physics model
        altitude_change_m = None
        if altitude is not None and truck_id in state_manager.last_sensor_data:
            prev_altitude = state_manager.last_sensor_data[truck_id].get("altitude")
            if prev_altitude is not None:
                altitude_change_m = altitude - prev_altitude

        # Validate ECU consumption
        validation = estimator.validate_ecu_consumption(
            ecu_consumption_lph=consumption_lph,
            dt_hours=dt_hours,
            engine_load_pct=engine_load,
            altitude_change_m=altitude_change_m,
            threshold_pct=30.0,  # 30% deviation threshold
        )

        # Log warnings for suspicious ECU readings
        if validation["status"] == "CRITICAL":
            logger.warning(
                f"âš ï¸ [ECU-VALIDATION] {truck_id}: {validation['message']} - "
                f"ECU={validation['ecu_lph']} LPH, Model={validation['model_lph']} LPH, "
                f"Deviation={validation['deviation_pct']}%"
            )
            # Send alert for critical ECU issues
            try:
                send_sensor_issue_alert(
                    truck_id=truck_id,
                    sensor_name="fuel_consumption_ecu",
                    issue_type="CRITICAL_DEVIATION",
                    severity="high",
                    current_value=validation["ecu_lph"],
                    expected_value=validation["model_lph"],
                    deviation_pct=validation["deviation_pct"],
                    message=validation["message"],
                )
            except Exception as e:
                logger.debug(f"Failed to send ECU validation alert: {e}")

        elif validation["status"] == "WARNING":
            logger.info(
                f"â„¹ï¸ [ECU-VALIDATION] {truck_id}: {validation['message']} - "
                f"ECU={validation['ecu_lph']} LPH, Model={validation['model_lph']} LPH, "
                f"Deviation={validation['deviation_pct']}%"
            )

    # ğŸ†• v3.12.28: Apply terrain factor to adjust consumption for grade
    # Only apply when moving and we have altitude data
    terrain_factor = 1.0
    if truck_status == "MOVING" and altitude is not None:
        terrain_factor = get_terrain_fuel_factor(
            truck_id=truck_id,
            altitude=altitude,
            latitude=sensor_data.get("latitude"),
            longitude=sensor_data.get("longitude"),
            speed=speed,
        )
        if consumption_lph is not None:
            consumption_lph = consumption_lph * terrain_factor

    # ğŸ†• v5.7.10: Apply load_factor to adjust consumption for engine load
    # Engine load significantly affects fuel consumption
    load_factor = 1.0
    if engine_load is not None and consumption_lph is not None:
        from mpg_engine import calculate_load_factor

        load_factor = calculate_load_factor(engine_load)
        consumption_lph = consumption_lph * load_factor
        logger.debug(
            f"[LOAD] {truck_id}: engine_load={engine_load}% -> load_factor={load_factor:.3f}"
        )

    # ğŸ”§ FIX v3.12.1: Use 'is not None' instead of truthy check
    # 0.0 is a valid consumption value, shouldn't become None
    consumption_gph = consumption_lph / 3.78541 if consumption_lph is not None else None

    # ğŸ”§ v5.8.2: Update sensor quality BEFORE predict phase (not after!)
    # This ensures the sensor_quality_factor is fresh when used in Q_L calculation
    is_engine_running = rpm is not None and rpm > 100
    estimator.update_sensor_quality(
        satellites=sats,
        voltage=pwr_int,
        is_engine_running=is_engine_running,
    )

    # ğŸ†• v3.12.32 QUICK WIN #4: Feed Sensor Health Monitor
    sensor_monitor = get_sensor_health_monitor()
    # Feed fuel sensor reading
    sensor_monitor.record_sensor_reading(
        truck_id=truck_id,
        sensor_name="fuel_pct",
        value=sensor_pct,
        timestamp=timestamp,
        is_valid=True,
    )
    # Feed speed sensor reading
    if speed is not None:
        sensor_monitor.record_sensor_reading(
            truck_id=truck_id,
            sensor_name="speed",
            value=speed,
            timestamp=timestamp,
            is_valid=True,
        )
    # Feed consumption reading
    if consumption_gph is not None:
        sensor_monitor.record_sensor_reading(
            truck_id=truck_id,
            sensor_name="consumption_gph",
            value=consumption_gph,
            timestamp=timestamp,
            is_valid=True,
        )

    # ğŸ”§ v5.8.2: Update adaptive Q_r based on truck status BEFORE predict
    # This adapts process noise to operational state (parked/idle/moving)
    estimator.update_adaptive_Q_r(
        speed=speed,
        rpm=rpm,
        consumption_lph=consumption_lph,
    )

    # Kalman predict phase (only if reasonable time delta)
    if dt_hours > 0 and dt_hours < 1.0:
        # ğŸ”§ v5.9.0: Q_L is now set by update_sensor_quality() above (line 1432)
        # No need to calculate_adaptive_noise - it was removed as dead code
        # The estimator.Q_L already contains the unified GPS + voltage adjustments

        # Predict
        estimator.predict(
            dt_hours=dt_hours,
            consumption_lph=consumption_lph,
            speed_mph=speed,
            rpm=rpm,  # ğŸ”§ v5.15.1: Pass RPM to detect engine-off state
        )

    # Check for refuel before update
    # ğŸ”§ v3.12.19: Use last_sensor_data instead of estimator.last_fuel_lvl_pct
    # This correctly compares consecutive sensor readings, not Kalman state
    refuel_event = None
    last_sensor_pct_for_refuel = None
    if truck_id in state_manager.last_sensor_data:
        prev_data = state_manager.last_sensor_data[truck_id]
        last_sensor_pct_for_refuel = prev_data.get("fuel_lvl")

    if sensor_pct is not None:
        # ğŸ” Debug: Log refuel check parameters (now using Kalman as baseline)
        kalman_pct = estimator.level_pct
        fuel_vs_kalman = sensor_pct - kalman_pct
        if fuel_vs_kalman > 10:  # Log significant jumps vs Kalman
            logger.info(
                f"[REFUEL-CHECK] {truck_id}: kalman={kalman_pct:.1f}%, sensor={sensor_pct:.1f}%, "
                f"diff={fuel_vs_kalman:.1f}%, gap={time_gap_hours*60:.1f}min"
            )

        refuel_event = detect_refuel(
            sensor_pct=sensor_pct,
            estimated_pct=kalman_pct,
            last_sensor_pct=last_sensor_pct_for_refuel,
            time_gap_hours=time_gap_hours,
            truck_status=truck_status,
            tank_capacity_gal=tank_capacity_gal,
            truck_id=truck_id,
        )

        if refuel_event:
            logger.info(
                f"ğŸš° [REFUEL-DETECTED] {truck_id}: {refuel_event['prev_pct']:.1f}% â†’ {refuel_event['new_pct']:.1f}% "
                f"(+{refuel_event['increase_pct']:.1f}%, +{refuel_event.get('increase_gal', 0):.1f} gal)"
            )

            # âœ… FIX DEC 25: Refuel saving is handled in sync_cycle() after process_truck()
            # The refuel_event dict is returned in metrics and saved with full error handling
            # This prevents crashes and ensures refuels are logged even if DB save fails

            # Hard reset after refuel
            estimator.apply_refuel_reset(
                new_fuel_pct=sensor_pct,
                timestamp=timestamp,
                gallons_added=refuel_event.get("increase_gal", 0),
            )
            reset_mpg_state(mpg_state, "REFUEL", truck_id)

    # Kalman update phase
    if sensor_pct is not None and not refuel_event:
        estimator.update(sensor_pct)

    # Check for theft with advanced detection (Time-of-Day + Sensor Health factors)
    theft_event = detect_fuel_theft(
        sensor_pct=sensor_pct,
        estimated_pct=estimator.level_pct,
        last_sensor_pct=estimator.last_fuel_lvl_pct,
        truck_status=truck_status,
        time_gap_hours=time_gap_hours,
        tank_capacity_gal=tank_capacity_gal,
        # Advanced detection parameters
        timestamp=timestamp,
        voltage=pwr_ext,
        gps_quality=gps_quality_str,
        sats=sats,
        latitude=latitude,
        longitude=longitude,
        speed_mph=speed,  # ğŸ†• v5.18.0: Speed gating (80% FP reduction)
    )

    # Update estimator timestamp
    estimator.last_update_time = timestamp

    # Calculate estimated values
    # ğŸ†• MEJORA-003: Fuel source fallback hierarchy
    # Priority: kalman (most accurate) â†’ raw_sensor â†’ last_known_good
    estimated_pct = estimator.level_pct
    estimated_liters = estimator.level_liters
    estimated_gallons = estimated_liters / 3.78541
    fuel_source = "kalman"

    # Fallback if Kalman failed
    if estimated_pct is None or estimated_pct < 0 or estimated_pct > 100:
        # Try raw sensor
        if sensor_pct is not None and 0 <= sensor_pct <= 100:
            estimated_pct = sensor_pct
            estimated_gallons = (sensor_pct / 100.0) * tank_capacity_gal
            estimated_liters = estimated_gallons * 3.78541
            fuel_source = "raw_sensor"
            logger.debug(f"[{truck_id}] Using raw sensor (Kalman unavailable)")
        else:
            # Both failed - use last known good from DB (if available)
            logger.warning(
                f"[{truck_id}] Both Kalman ({estimated_pct}) and sensor ({sensor_pct}) failed - "
                f"check sensors or estimator state"
            )
            # Note: Could implement _get_last_known_fuel(truck_id) DB query here if needed
            # For now, we'll let the values be None which will skip DB insert
            fuel_source = "none"

    # Sensor values (raw)
    sensor_liters = (sensor_pct / 100) * tank_capacity_liters if sensor_pct else None
    sensor_gallons = (sensor_pct / 100) * tank_capacity_gal if sensor_pct else None

    # Calculate drift
    drift_pct = 0.0
    if sensor_pct is not None and estimated_pct is not None:
        drift_pct = estimated_pct - sensor_pct
    drift_warning = "YES" if abs(drift_pct) > 7.5 else "NO"

    # ğŸ”§ DEC 29 FIX: MPG calculation - SOLO mÃ©todo acumulador (matching production)
    # REMOVED: Instantaneous MPG (speed/consumption) - demasiado ruidoso
    # USING: Accumulator pattern con ventanas (5mi + 0.75gal) y EMA smoothing
    mpg_current = mpg_state.mpg_current

    # ğŸ”§ FIX v6.4.0: Reset fuel tracking when there's a large time gap
    # This prevents fuel consumed during IDLE from corrupting MPG calculations
    if time_gap_hours > 0.5:  # More than 30 minutes gap
        if mpg_state.last_fuel_lvl_pct is not None:
            sensor_info = f"{sensor_pct:.1f}%" if sensor_pct is not None else "N/A"
            logger.debug(
                f"[{truck_id}] Large time gap ({time_gap_hours:.1f}h) - resetting fuel tracking "
                f"(was at {mpg_state.last_fuel_lvl_pct:.1f}%, now {sensor_info})"
            )
        mpg_state.last_fuel_lvl_pct = None  # Force fresh start
        mpg_state.last_timestamp = None

    # ğŸ†• DEC24: Accumulated MPG calculation (matching production logic)
    # Ventanas: â‰¥5mi AND â‰¥0.75gal â†’ calcular MPG â†’ aplicar EMA smoothing
    # LÃ­mites fÃ­sicos: 3.5-9.0 MPG (Class 8 trucks - matching production)
    if truck_status == "MOVING" and speed and speed > 5:
        # Calculate deltas
        delta_miles = 0.0
        delta_gallons = 0.0

        # ğŸ”§ FIX #2: Calculate delta_miles with speedÃ—time fallback
        # âœ… v5.18.0 NOTE: Este fix YA ESTABA IMPLEMENTADO en v6.4.0
        # Resuelve el problema de 85% registros sin odometer
        # Permite calcular MPG incluso cuando odometer = NULL
        if mpg_state.last_odometer_mi is not None and odometer and odometer > 0:
            # Method 1: Odometer delta (preferred)
            delta_miles = odometer - mpg_state.last_odometer_mi
            if (
                delta_miles < 0 or delta_miles > 500
            ):  # âœ… DEC 22: Increased from 50 to 500 (trucks can travel 12h Ã— 65mph = 780mi)
                # Fallback to speed Ã— time
                delta_miles = speed * dt_hours if dt_hours > 0 else 0.0
                logger.debug(
                    f"[{truck_id}] Odometer invalid ({delta_miles:.1f}mi) - using speed-based: {speed * dt_hours:.2f}mi"
                )
        else:
            # Method 2: Speed Ã— time (fallback when no odometer)
            # âœ… CRITICAL: Este fallback permite MPG calculation sin odometer
            delta_miles = speed * dt_hours if dt_hours > 0 else 0.0

        # ğŸ†• DEC 23 FIX (BUG-002): Store odom_delta_mi for cost_per_mile calculation
        # Validate delta_miles is reasonable before storing
        MIN_DELTA_MILES = 0.1
        MAX_DELTA_MILES = 500
        odom_delta_mi = (
            delta_miles if (MIN_DELTA_MILES < delta_miles < MAX_DELTA_MILES) else None
        )

        # ğŸ”§ DEC 29 FIX v2: NUEVO orden de prioridad para fuel consumption (MPG accuracy fix)
        # PRIORITY 1: ECU total_fuel_used delta - Cumulative counter, most precise for MPG
        # PRIORITY 2: Kalman filter (estimated_gallons) - Good for smoothing but can underestimate consumption
        # PRIORITY 3: Raw sensor_pct delta - Only as fallback (noisy, can jump erratically)
        # PRIORITY 4: fuel_rate_gph - Last resort (instantaneous, very noisy)
        #
        # RATIONALE: Logs show "Fuel rate mismatch: ECU=4.71gph, estimated=1.30gph"
        # Kalman underestimates consumption by ~2-3x, causing inflated MPG (7-8 instead of 4-5)
        # ECU cumulative counter is Â±0.1% accurate, better for MPG than Kalman's conservative estimates

        total_fuel_used = sensor_data.get("total_fuel_used")  # Already in gallons
        last_total_fuel = (
            mpg_state.last_total_fuel_gal
            if hasattr(mpg_state, "last_total_fuel_gal")
            else None
        )

        # ğŸ”§ v6.5.1 DEC 29 CRITICAL FIX: MPG usando SOLO sensor_pct (como producciÃ³n)
        # PROBLEMA DETECTADO: ECU cumulative reporta consumo MENOR que realidad
        # - ECU mide fuel inyectado (no cuenta retorno, evaporaciÃ³n)
        # - Resultado: MPG inflado 20-70% vs producciÃ³n
        # SOLUCIÃ“N: Usar SOLO sensor % como producciÃ³n Windows

        # âœ… Verificar que tenemos AMBAS lecturas (actual Y previa)
        has_odometer = (
            mpg_state.last_odometer_mi is not None
            and odometer is not None
            and odometer > 0
        )
        has_fuel_lvl = (
            mpg_state.last_fuel_lvl_pct is not None and sensor_pct is not None
        )

        # Solo calcular MPG si AMBOS estÃ¡n disponibles
        if has_odometer and has_fuel_lvl:
            # Calcular delta fuel (% consumido) - SOLO SENSOR
            fuel_drop_pct = mpg_state.last_fuel_lvl_pct - sensor_pct

            # SKIP si fuel subiÃ³ (refuel detectado)
            if fuel_drop_pct < -5:
                logger.debug(
                    f"[{truck_id}] Refuel detected (+{-fuel_drop_pct:.1f}%), "
                    f"skipping MPG calculation"
                )
            # SKIP si fuel no cambiÃ³ significativamente
            elif fuel_drop_pct < 0.05:
                logger.debug(
                    f"[{truck_id}] Fuel change too small ({fuel_drop_pct:.2f}%), "
                    f"skipping MPG calculation"
                )
            # SKIP si fuel drop extremo (sensor error)
            elif fuel_drop_pct > 50:
                logger.warning(
                    f"[{truck_id}] Fuel drop too large ({fuel_drop_pct:.1f}%) - "
                    f"likely sensor error, skipping MPG calculation"
                )
            else:
                # âœ… TODO VÃLIDO - calcular delta_gallons
                delta_gallons = (fuel_drop_pct / 100) * tank_capacity_gal
                odom_delta_mi = delta_miles  # Para cost_per_mile calculation
                mpg_state.fuel_source_stats["sensor"] = (
                    mpg_state.fuel_source_stats.get("sensor", 0) + 1
                )

                logger.debug(
                    f"[{truck_id}] Î” odometer: {delta_miles:.2f}mi, "
                    f"Î” fuel: {fuel_drop_pct:.2f}% ({delta_gallons:.2f} gal)"
                )
        else:
            # Skip este ciclo - esperar a que AMBOS estÃ©n disponibles
            missing = []
            if not has_odometer:
                missing.append("odometer")
            if not has_fuel_lvl:
                missing.append("fuel_lvl")
            logger.debug(
                f"[{truck_id}] Skipping MPG - waiting for: {', '.join(missing)}"
            )

        # ğŸ”§ v2.0.1: VALIDACIONES ESTRICTAS antes de calcular MPG
        # Evita corruption por deltas irreales (odometer jumps, sensor glitches)
        MAX_DELTA_MILES = 500  # âœ… DEC 22: Increased from 100 to 500 (long haul trucks)
        MAX_DELTA_FUEL = (
            100  # âœ… DEC 22: Increased from 25 to 100 (500mi Ã· 5mpg = 100 gal)
        )
        MIN_DELTA_MILES = 0.1  # Al menos 0.1 milla
        MIN_DELTA_FUEL = 0.01  # Al menos 0.01 galÃ³n

        # Validar deltas antes de actualizar MPG
        if (
            MIN_DELTA_MILES < delta_miles < MAX_DELTA_MILES
            and MIN_DELTA_FUEL < delta_gallons < MAX_DELTA_FUEL
        ):
            # âœ… DEC 29: Add MPG physics validation matching PRODUCTION
            instant_mpg = delta_miles / delta_gallons if delta_gallons > 0 else 0

            # ğŸ†• DEC 29 PRODUCTION MATCH: Rango 2.0-12.0 (matching Windows production)
            # Realistic MPG range for heavy trucks: 4-9 typical, 2-12 allowed
            # Out-of-range values indicate sensor errors or bad data
            if 2.0 <= instant_mpg <= 12.0:
                # Additional warning for borderline values
                if instant_mpg < 4.0 or instant_mpg > 9.0:
                    logger.warning(
                        f"[{truck_id}] Borderline MPG: {instant_mpg:.2f} "
                        f"(typical range: 4-9, allowing 2-12) - "
                        f"Î”mi={delta_miles:.1f}, Î”gal={delta_gallons:.2f}"
                    )

                # Fuel source always "tank_level" now (sensor-only)
                fuel_source = "tank_level"

                logger.info(
                    f"[{truck_id}] âœ“ MPG={instant_mpg:.2f} (Î”mi={delta_miles:.1f}, Î”gal={delta_gallons:.2f}, source={fuel_source})"
                )

                # ğŸ”§ FIX DEC 29: Pass tank_capacity_gal for correct SNR calculation
                mpg_state = update_mpg_state(
                    mpg_state,
                    delta_miles,
                    delta_gallons,
                    mpg_config,
                    truck_id,
                    tank_capacity_gal=tank_capacity_gal,
                )
                mpg_current = mpg_state.mpg_current
            else:
                logger.warning(
                    f"[{truck_id}] âŒ MPG {instant_mpg:.2f} out of range (2-12), discarding "
                    f"(Î”mi={delta_miles:.1f}, Î”gal={delta_gallons:.2f})"
                )
        elif delta_miles > 0 or delta_gallons > 0:
            logger.debug(
                f"[{truck_id}] Deltas fuera de rango - descartados: "
                f"miles={delta_miles:.2f} (max={MAX_DELTA_MILES}), "
                f"fuel={delta_gallons:.3f} (max={MAX_DELTA_FUEL})"
            )

        # Update tracking values (matching production)
        if odometer and odometer > 0 and odometer < 10_000_000:  # Validar odometer
            mpg_state.last_odometer_mi = odometer
        mpg_state.last_fuel_lvl_pct = sensor_pct
        mpg_state.last_timestamp = timestamp.timestamp()
        # No update last_total_fuel_gal since we're not using ECU anymore
        # ğŸ†• DEC 29: Store Kalman estimate for next delta calculation
        if estimated_gallons is not None:
            mpg_state.last_estimated_gal = estimated_gallons

    # Idle consumption calculation
    idle_gph = 0.0
    idle_method = "NOT_IDLE"
    idle_mode = None

    if truck_status == "STOPPED":
        previous_fuel_L = None
        previous_idle_fuel = None  # ğŸ†• v5.3.3: Track previous ECU idle counter
        previous_idle_gph = None  # ğŸ†• v5.4.3: For EMA smoothing

        if truck_id in state_manager.last_sensor_data:
            prev = state_manager.last_sensor_data[truck_id]
            if prev.get("fuel_lvl"):
                previous_fuel_L = (prev["fuel_lvl"] / 100) * tank_capacity_liters
            # ğŸ†• v5.3.3: Get previous ECU idle fuel counter
            previous_idle_fuel = prev.get("total_idle_fuel")
            # ğŸ†• v5.4.3: Get previous idle GPH for EMA smoothing
            previous_idle_gph = prev.get("idle_gph")

        idle_gph, method_enum = calculate_idle_consumption(
            truck_status=truck_status,
            rpm=rpm,
            fuel_rate=fuel_rate,
            current_fuel_L=estimated_liters,
            previous_fuel_L=previous_fuel_L,
            time_delta_hours=dt_hours,
            config=idle_config,
            truck_id=truck_id,
            temperature_f=coolant_temp,
            # ğŸ†• v5.3.3: Pass ECU idle fuel counter for highest accuracy (Â±0.1%)
            total_idle_fuel=total_idle_fuel,
            previous_total_idle_fuel=previous_idle_fuel,
            # ğŸ†• v5.4.3: Pass previous idle GPH for EMA smoothing
            previous_idle_gph=previous_idle_gph,
        )
        idle_method = method_enum.value
        idle_mode_enum = detect_idle_mode(idle_gph, idle_config)
        idle_mode = idle_mode_enum.value

    # Anchor detection
    anchor_detected = "NO"
    anchor_type = "NONE"

    if truck_status == "STOPPED":
        anchor = anchor_detector.check_static_anchor(
            timestamp=timestamp,
            speed=speed,
            rpm=rpm,
            fuel_pct=sensor_pct,
            hdop=hdop,
            drift_pct=drift_pct,
        )
        if anchor:
            anchor_detected = "YES"
            anchor_type = "STATIC"
    elif truck_status == "MOVING" and speed and speed > 30:
        anchor = anchor_detector.check_micro_anchor(
            timestamp=timestamp,
            speed=speed,
            fuel_pct=sensor_pct,
            hdop=hdop,
            altitude_ft=altitude,
            drift_pct=drift_pct,
        )
        if anchor:
            anchor_detected = "YES"
            anchor_type = "MICRO"

    # Store last sensor data for next cycle
    # ğŸ†• v5.4.3: Include idle_gph for EMA smoothing
    sensor_data["idle_gph"] = idle_gph
    state_manager.last_sensor_data[truck_id] = sensor_data

    # ğŸ†• DEC 23: Apply Enhanced MPG environmental adjustments
    # ğŸš« TEMPORALMENTE DESHABILITADO - debugging en progreso
    # Normalize MPG for altitude, temperature, and load factors
    enhanced_mpg = None
    # if mpg_current is not None:
    #     # Get adjusted MPG (normalized to baseline conditions)
    #     enhanced_mpg_result = enhanced_mpg_calculator.adjust_mpg(
    #         raw_mpg=mpg_current,
    #         altitude_ft=altitude if altitude else 0,
    #         ambient_temp_f=ambient_temp if ambient_temp else 70.0,
    #         load_lbs=0  # TODO: Get from weight sensor when available
    #     )
    #
    #     enhanced_mpg = enhanced_mpg_result.get("adjusted_mpg", mpg_current)
    #
    #     if enhanced_mpg != mpg_current:
    #         logger.debug(
    #             f"[ENHANCED_MPG] {truck_id}: raw={mpg_current:.2f} -> normalized={enhanced_mpg:.2f} "
    #             f"(alt={altitude or 0:.0f}ft, temp={ambient_temp or 70:.1f}Â°F)"
    #         )

    # ğŸ†• v5.7.10: Calculate weather-adjusted MPG (LEGACY - keep for compatibility)
    # If ambient_temp is available, adjust expected MPG for display
    weather_adjusted_mpg = None
    weather_mpg_factor = None
    if mpg_current is not None and ambient_temp is not None:
        from mpg_engine import calculate_weather_mpg_factor

        weather_mpg_factor = calculate_weather_mpg_factor(ambient_temp)
        weather_adjusted_mpg = mpg_current * weather_mpg_factor

    # ğŸ†• DEC 24 2025: Validate MPG against truck-specific baseline
    mpg_validation = None
    mpg_expected = None
    mpg_deviation_pct = None
    mpg_status = None

    if mpg_current is not None:
        try:
            # Determine if truck is loaded (speed > 5 and fuel consumption indicates loaded)
            # Simple heuristic: if moving and consuming fuel, assume loaded
            is_loaded = truck_status in ["MOVING", "IDLE"] and speed > 5

            mpg_validation = validate_truck_mpg(truck_id, mpg_current, is_loaded)

            if mpg_validation and "expected_mpg" in mpg_validation:
                mpg_expected = mpg_validation["expected_mpg"]
                mpg_deviation_pct = mpg_validation["deviation_pct"]
                mpg_status = mpg_validation["status"]

                # Log warnings/criticals
                if mpg_status == "CRITICAL":
                    logger.warning(
                        f"ğŸš¨ [{truck_id}] MPG CRITICAL: {mpg_current:.1f} vs expected {mpg_expected:.1f} "
                        f"({mpg_deviation_pct:.1f}%) - {mpg_validation.get('truck_info', '')}"
                    )
                    # Send alert for critical underperformance
                    try:
                        from alert_service import send_mpg_underperformance_alert

                        send_mpg_underperformance_alert(
                            truck_id,
                            mpg_current,
                            mpg_expected,
                            mpg_deviation_pct,
                            mpg_validation.get("truck_info"),
                        )
                    except Exception as e:
                        logger.debug(f"MPG alert failed: {e}")
                elif mpg_status == "WARNING":
                    logger.info(
                        f"âš ï¸  [{truck_id}] MPG WARNING: {mpg_current:.1f} vs expected {mpg_expected:.1f} "
                        f"({mpg_deviation_pct:.1f}%)"
                    )
        except Exception as e:
            logger.debug(f"[{truck_id}] MPG validation skipped: {e}")

        if weather_mpg_factor is not None and weather_mpg_factor != 1.0:
            logger.debug(
                f"[WEATHER] {truck_id}: ambient={ambient_temp}Â°F -> factor={weather_mpg_factor:.3f}, "
                f"raw_mpg={mpg_current:.2f}, adjusted={weather_adjusted_mpg:.2f}"
            )

    # ğŸ†• v3.12.32 QUICK WIN #2: Calculate Confidence Score
    confidence = calculate_estimation_confidence(
        sensor_pct=sensor_pct,
        time_gap_hours=time_gap_hours,
        gps_satellites=sats,
        battery_voltage=pwr_ext,
        kalman_variance=estimator.P if estimator else 50.0,
        sensor_age_seconds=int(data_age_min * 60),
        ecu_available=total_fuel_used is not None,
        speed=speed,
        drift_pct=abs(drift_pct) if drift_pct is not None else 0,
        rpm=rpm,
    )

    # Return complete metrics
    return {
        "timestamp_utc": timestamp,
        "truck_id": truck_id,
        "carrier_id": "skylord",
        "truck_status": truck_status,
        "latitude": latitude,
        "longitude": longitude,
        "speed_mph": speed,
        "estimated_liters": round(estimated_liters, 2) if estimated_liters else None,
        "estimated_gallons": round(estimated_gallons, 2) if estimated_gallons else None,
        "estimated_pct": round(estimated_pct, 2) if estimated_pct else None,
        "sensor_pct": sensor_pct,
        "sensor_liters": round(sensor_liters, 2) if sensor_liters else None,
        "sensor_gallons": round(sensor_gallons, 2) if sensor_gallons else None,
        "consumption_lph": round(consumption_lph, 2) if consumption_lph else None,
        "consumption_gph": round(consumption_gph, 3) if consumption_gph else None,
        # âœ… DEC 23: Store real MPG without artificial cap
        # Class 8 trucks: empty highway 8-12 MPG, loaded highway 5-7 MPG, city 4-6 MPG
        "mpg_current": round(mpg_current, 2) if mpg_current else None,
        # ğŸ†• DEC 23: Enhanced MPG (normalized for environmental factors)
        "mpg_enhanced": round(enhanced_mpg, 2) if enhanced_mpg else None,
        # ğŸ†• v2.0.1: Cost per mile calculation (fuel_price / mpg)
        # ğŸ”§ DEC 26 FIX (BUG-007): Use dynamic price from service container
        "cost_per_mile": (
            round(get_container().settings.fuel.price_per_gallon / mpg_current, 3)
            if mpg_current and mpg_current > 0
            else None
        ),
        # ğŸ†• DEC 23 FIX (BUG-002): Add odom_delta_mi
        "odom_delta_mi": round(odom_delta_mi, 3) if odom_delta_mi else None,
        # ğŸ†• v5.7.10: Weather-adjusted MPG for display (LEGACY)
        "mpg_weather_adjusted": (
            round(weather_adjusted_mpg, 2) if weather_adjusted_mpg else None
        ),
        "weather_mpg_factor": (
            round(weather_mpg_factor, 3) if weather_mpg_factor else None
        ),
        "rpm": int(rpm) if rpm else None,
        "engine_hours": engine_hours,
        "odometer_mi": odometer,
        "altitude_ft": altitude,
        "hdop": hdop,
        "coolant_temp_f": coolant_temp,
        "idle_gph": round(idle_gph, 3) if idle_gph else None,
        "idle_method": idle_method,
        "idle_mode": idle_mode,
        "drift_pct": round(drift_pct, 2),
        "drift_warning": drift_warning,
        "anchor_detected": anchor_detected,
        "anchor_type": anchor_type,
        "data_age_min": round(data_age_min, 2),
        "refuel_detected": "YES" if refuel_event else "NO",
        "theft_detected": "YES" if theft_event else "NO",
        # Refuel event details for persistence and notifications
        "refuel_event": refuel_event,
        # ğŸ”§ v5.5.3: Use prev_pct from refuel_event (already calculated to be consistent)
        "fuel_before_pct": refuel_event.get("prev_pct") if refuel_event else None,
        # ğŸ†• v3.12.26: Engine Health sensors
        "oil_pressure_psi": oil_press,
        "oil_temp_f": oil_temp,
        "battery_voltage": pwr_ext,
        "engine_load_pct": engine_load,
        "def_level_pct": def_level,
        "intake_air_temp_f": intake_air_temp,
        # ğŸ†• v5.12.2: Additional temp/pressure sensors for predictive maintenance
        "trans_temp_f": trans_temp,
        "fuel_temp_f": fuel_temp,
        "intercooler_temp_f": intercooler_temp,
        "intake_press_kpa": intake_press,
        "retarder_level": retarder,
        # ğŸ†• v5.3.3: Ambient temperature for weather-adjusted alerts
        "ambient_temp_f": ambient_temp,
        # ğŸ†• v3.12.28: Terrain factor for grade-adjusted consumption
        "terrain_factor": round(terrain_factor, 3),
        # ğŸ†• v5.7.10: Load factor for engine-load-adjusted consumption
        "load_factor": round(load_factor, 3),
        # ğŸ†• v5.7.1: New sensor data for ML and diagnostics
        "sats": sats,
        "pwr_int": pwr_int,
        "gps_quality": gps_quality_str,  # ğŸ†• v5.7.3: Descriptive format QUALITY|sats=X|acc=Ym
        "idle_hours_ecu": sensor_data.get("idle_hours"),
        # ğŸ†• v5.7.5: DTC data for diagnostic display
        "dtc": sensor_data.get("dtc"),  # Count/flag (0=none, >0=active)
        "dtc_code": sensor_data.get("dtc_code"),  # Actual codes like "100.4,157.3"
        # ğŸ”§ v5.8.2: Kalman confidence for debugging and ML
        # P is covariance, lower = more confident (typical range 0.5-10)
        "kalman_confidence": round(1.0 / (1.0 + estimator.P), 3) if estimator else None,
        "kalman_P": round(estimator.P, 3) if estimator else None,
        # ğŸ†• v3.12.32 QUICK WIN #2: Confidence Scoring
        "confidence_score": confidence.score,
        "confidence_level": confidence.level.value,
        "confidence_warnings": (
            "; ".join(confidence.warnings) if confidence.warnings else None
        ),
        # ğŸ†• DEC 24 2025: Truck-specific MPG validation
        "mpg_expected": mpg_expected,
        "mpg_deviation_pct": mpg_deviation_pct,
        "mpg_status": mpg_status,
    }


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# DATABASE INSERT
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


def save_dtc_event(connection, truck_id: str, alert, sensor_data: Dict) -> bool:
    """
    ğŸ†• v5.7.3: Save DTC event to dtc_events table for history and ML.

    Args:
        connection: MySQL connection
        truck_id: Truck identifier
        alert: DTCAlert from dtc_analyzer
        sensor_data: Current sensor data for context

    Returns:
        True if saved successfully
    """
    if not alert.codes:
        return False

    try:
        with connection.cursor() as cursor:
            for code in alert.codes:
                # Check for duplicate (same truck, code, within 5 minutes)
                cursor.execute(
                    """
                    SELECT id FROM dtc_events 
                    WHERE truck_id = %s AND dtc_code = %s 
                    AND timestamp_utc > DATE_SUB(NOW(), INTERVAL 5 MINUTE)
                    LIMIT 1
                """,
                    (truck_id, code.code),
                )

                if cursor.fetchone():
                    logger.debug(f"Skipping duplicate DTC {code.code} for {truck_id}")
                    continue

                cursor.execute(
                    """
                    INSERT INTO dtc_events 
                    (truck_id, unit_id, timestamp_utc, dtc_code, component,
                     severity, status, description, action_required)
                    VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)
                """,
                    (
                        truck_id,
                        sensor_data.get("unit_id"),
                        datetime.now(timezone.utc),
                        code.code,
                        getattr(code, "component", None) or code.description,
                        alert.severity.value,
                        "NEW",
                        code.description or alert.message,
                        getattr(code, "recommended_action", None),
                    ),
                )

            connection.commit()
            logger.info(f"ğŸ’¾ Saved {len(alert.codes)} DTC(s) for {truck_id}")
            return True

    except Exception as e:
        logger.error(f"Error saving DTC for {truck_id}: {e}")
        return False


def save_dtc_event_hybrid(
    connection, truck_id: str, dtc_info: Dict, unit_id: Optional[str] = None
) -> bool:
    """
    ğŸ†• DEC 26 2025: Save DTC event using HYBRID decoder system (781,066 DTCs).

    This function uses the new dtc_decoder.py hybrid system with:
    - 111 SPNs with DETAILED explanations (Spanish)
    - 35,503 SPNs with COMPLETE coverage (basic)
    - 22 FMI codes (0-21)
    - OEM detection (Freightliner, Detroit, Volvo, etc.)
    - has_detailed_info flag (DETAILED vs COMPLETE)

    Args:
        connection: MySQL connection
        truck_id: Truck identifier
        dtc_info: Dict from FuelCopilotDTCHandler.process_wialon_dtc()
        unit_id: Optional Wialon unit ID (not used currently, table doesn't have this column)

    Returns:
        True if saved successfully

    Example dtc_info structure:
        {
            'dtc_code': '100.1',
            'spn': 100,
            'fmi': 1,
            'description': 'PresiÃ³n de aceite del motor',
            'spn_explanation': 'PresiÃ³n del aceite del motor muy baja...',
            'fmi_explanation': 'Datos vÃ¡lidos pero por debajo del rango normal...',
            'has_detailed_info': True,
            'severity': 'CRITICAL',
            'category': 'ENGINE',
            'is_critical': True,
            'action_required': 'Detener el motor inmediatamente...',
            'oem': 'All OEMs',
            'truck_id': 'TRK001'
        }
    """
    try:
        # Validate required fields
        if (
            not dtc_info.get("dtc_code")
            or not dtc_info.get("spn")
            or dtc_info.get("fmi") is None
        ):
            logger.warning(f"Missing required DTC fields: {dtc_info}")
            return False

        with connection.cursor() as cursor:
            # Check for duplicate (same truck, code, unresolved)
            cursor.execute(
                """
                SELECT id FROM dtc_events 
                WHERE truck_id = %s 
                AND dtc_code = %s 
                AND status IN ('NEW', 'ACTIVE')
                LIMIT 1
                """,
                (truck_id, dtc_info["dtc_code"]),
            )

            if cursor.fetchone():
                logger.debug(
                    f"Skipping duplicate active DTC {dtc_info['dtc_code']} for {truck_id}"
                )
                return False

            # Insert new DTC event with HYBRID system data
            cursor.execute(
                """
                INSERT INTO dtc_events 
                (truck_id, timestamp_utc, dtc_code, spn, fmi,
                 component, severity, category, status, description, 
                 action_required, is_critical, spn_explanation, fmi_explanation, 
                 has_detailed_info, oem)
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                """,
                (
                    truck_id,
                    datetime.now(timezone.utc),
                    dtc_info["dtc_code"],
                    dtc_info["spn"],
                    dtc_info["fmi"],
                    dtc_info.get("category", "UNKNOWN"),  # component column
                    dtc_info.get("severity", "WARNING"),
                    dtc_info.get("category", "UNKNOWN"),
                    "NEW",
                    dtc_info.get("description", "Unknown DTC"),
                    dtc_info.get("action_required"),
                    dtc_info.get("is_critical", False),
                    dtc_info.get("spn_explanation"),
                    dtc_info.get("fmi_explanation"),
                    dtc_info.get("has_detailed_info", False),
                    dtc_info.get("oem", "All OEMs"),
                ),
            )

            connection.commit()
            detailed = (
                "âœ¨ DETAILED" if dtc_info.get("has_detailed_info") else "ğŸ“‹ COMPLETE"
            )
            logger.info(
                f"ğŸ’¾ {detailed} Saved DTC {dtc_info['dtc_code']} for {truck_id}"
            )
            return True

    except Exception as e:
        logger.error(f"Error saving hybrid DTC for {truck_id}: {e}")
        return False


def save_to_fuel_metrics(connection, metrics: Dict) -> int:
    """Insert processed metrics into fuel_metrics table"""
    # Convert PARKED to OFFLINE for database compatibility
    # The DB schema only supports MOVING/STOPPED/OFFLINE
    db_status = metrics.get("truck_status", "OFFLINE")
    if db_status == "PARKED":
        db_status = "OFFLINE"
    metrics["truck_status"] = db_status

    try:
        with connection.cursor() as cursor:
            # ğŸ†• v5.3.3: Added ambient_temp_f and intake_air_temp_f columns
            # ğŸ”§ FIX v5.4.7: Added idle_gph to INSERT (was missing - BUG #1 from audit)
            # ğŸ†• v5.7.1: Added sats, pwr_int, terrain_factor, gps_quality, idle_hours_ecu
            # ğŸ†• v5.7.5: Added dtc, dtc_code for diagnostic tracking
            # ğŸ†• DEC 24 2025: Added mpg_expected, mpg_deviation_pct, mpg_status for truck-specific validation
            query = """
                INSERT INTO fuel_metrics 
                (timestamp_utc, truck_id, carrier_id, truck_status,
                 latitude, longitude, speed_mph,
                 estimated_liters, estimated_gallons, estimated_pct,
                 sensor_pct, sensor_liters, sensor_gallons,
                 consumption_lph, consumption_gph, mpg_current, cost_per_mile,
                 rpm, engine_hours, odometer_mi, odom_delta_mi,
                 altitude_ft, hdop, coolant_temp_f,
                 idle_gph, idle_method, idle_mode, drift_pct, drift_warning,
                 anchor_detected, anchor_type, data_age_min,
                 oil_pressure_psi, oil_temp_f, battery_voltage, 
                 engine_load_pct, def_level_pct,
                 ambient_temp_f, intake_air_temp_f,
                 trans_temp_f, fuel_temp_f, intercooler_temp_f, intake_press_kpa, retarder_level,
                 sats, pwr_int, terrain_factor, gps_quality, idle_hours_ecu,
                 dtc, dtc_code, mpg_expected, mpg_deviation_pct, mpg_status)
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                ON DUPLICATE KEY UPDATE
                    truck_status = VALUES(truck_status),
                    latitude = VALUES(latitude),
                    longitude = VALUES(longitude),
                    speed_mph = VALUES(speed_mph),
                    estimated_liters = VALUES(estimated_liters),
                    estimated_gallons = VALUES(estimated_gallons),
                    estimated_pct = VALUES(estimated_pct),
                    sensor_pct = VALUES(sensor_pct),
                    sensor_liters = VALUES(sensor_liters),
                    sensor_gallons = VALUES(sensor_gallons),
                    consumption_lph = VALUES(consumption_lph),
                    consumption_gph = VALUES(consumption_gph),
                    mpg_current = VALUES(mpg_current),
                    cost_per_mile = VALUES(cost_per_mile),
                    rpm = VALUES(rpm),
                    engine_hours = VALUES(engine_hours),
                    odometer_mi = VALUES(odometer_mi),
                    odom_delta_mi = VALUES(odom_delta_mi),
                    altitude_ft = VALUES(altitude_ft),
                    hdop = VALUES(hdop),
                    coolant_temp_f = VALUES(coolant_temp_f),
                    idle_gph = VALUES(idle_gph),
                    idle_method = VALUES(idle_method),
                    idle_mode = VALUES(idle_mode),
                    drift_pct = VALUES(drift_pct),
                    drift_warning = VALUES(drift_warning),
                    data_age_min = VALUES(data_age_min),
                    oil_pressure_psi = VALUES(oil_pressure_psi),
                    oil_temp_f = VALUES(oil_temp_f),
                    battery_voltage = VALUES(battery_voltage),
                    engine_load_pct = VALUES(engine_load_pct),
                    def_level_pct = VALUES(def_level_pct),
                    ambient_temp_f = VALUES(ambient_temp_f),
                    intake_air_temp_f = VALUES(intake_air_temp_f),
                    trans_temp_f = VALUES(trans_temp_f),
                    fuel_temp_f = VALUES(fuel_temp_f),
                    intercooler_temp_f = VALUES(intercooler_temp_f),
                    intake_press_kpa = VALUES(intake_press_kpa),
                    retarder_level = VALUES(retarder_level),
                    sats = VALUES(sats),
                    pwr_int = VALUES(pwr_int),
                    terrain_factor = VALUES(terrain_factor),
                    gps_quality = VALUES(gps_quality),
                    idle_hours_ecu = VALUES(idle_hours_ecu),
                    dtc = VALUES(dtc),
                    dtc_code = VALUES(dtc_code),
                    mpg_expected = VALUES(mpg_expected),
                    mpg_deviation_pct = VALUES(mpg_deviation_pct),
                    mpg_status = VALUES(mpg_status)
            """

            values = (
                metrics["timestamp_utc"],
                metrics["truck_id"],
                metrics["carrier_id"],
                metrics["truck_status"],
                metrics["latitude"],
                metrics["longitude"],
                metrics["speed_mph"],
                metrics["estimated_liters"],
                metrics["estimated_gallons"],
                metrics["estimated_pct"],
                metrics["sensor_pct"],
                metrics["sensor_liters"],
                metrics["sensor_gallons"],
                metrics["consumption_lph"],
                metrics["consumption_gph"],
                metrics["mpg_current"],
                metrics.get("cost_per_mile"),
                metrics["rpm"],
                metrics["engine_hours"],
                metrics["odometer_mi"],
                metrics.get("odom_delta_mi"),  # ğŸ†• DEC 23 FIX (BUG-002)
                metrics["altitude_ft"],
                metrics["hdop"],
                metrics["coolant_temp_f"],
                # ğŸ”§ FIX v5.4.7: Added idle_gph value (was missing - BUG #1)
                metrics.get("idle_gph"),
                metrics["idle_method"],
                metrics["idle_mode"],
                metrics["drift_pct"],
                metrics["drift_warning"],
                metrics["anchor_detected"],
                metrics["anchor_type"],
                metrics["data_age_min"],
                # ğŸ†• v3.12.26: Engine Health sensors
                metrics.get("oil_pressure_psi"),
                metrics.get("oil_temp_f"),
                metrics.get("battery_voltage"),
                metrics.get("engine_load_pct"),
                metrics.get("def_level_pct"),
                # ğŸ†• v5.3.3: Temperature sensors for weather-adjusted alerts
                metrics.get("ambient_temp_f"),
                metrics.get("intake_air_temp_f"),
                # ğŸ†• v5.12.2: Additional temperature/pressure sensors for predictive maintenance
                metrics.get("trans_temp_f"),
                metrics.get("fuel_temp_f"),
                metrics.get("intercooler_temp_f"),
                metrics.get("intake_press_kpa"),
                metrics.get("retarder_level"),
                # ğŸ†• v5.7.1: New sensor columns for ML and diagnostics
                metrics.get("sats"),
                metrics.get("pwr_int"),
                metrics.get("terrain_factor"),
                metrics.get("gps_quality"),
                metrics.get("idle_hours_ecu"),
                # ğŸ†• v5.7.5: DTC columns
                metrics.get("dtc"),
                metrics.get("dtc_code"),
                # ğŸ†• DEC 24 2025: MPG validation columns
                metrics.get("mpg_expected"),
                metrics.get("mpg_deviation_pct"),
                metrics.get("mpg_status"),
            )

            cursor.execute(query, values)
            return cursor.rowcount

    except Exception as e:
        logger.error(f"Error saving metrics for {metrics.get('truck_id')}: {e}")
        return 0


def process_2abc_integrations(truck_id: str, sensor_data: Dict) -> Dict[str, Any]:
    """
    ğŸ†• FASES 2A, 2B, 2C: Process sensor data through ML pipeline

    Integrates:
    - FASE 2A: EKF multi-sensor fusion
    - FASE 2B: LSTM predictions + Anomaly detection
    - FASE 2C: Event publishing + Driver behavior scoring

    Args:
        truck_id: Truck ID
        sensor_data: Raw sensor data from Wialon

    Returns:
        Dict with results from all phases
    """
    results = {}

    if not _wialon_2abc:
        return results

    try:
        # ğŸ†• FASE 2A: Update EKF with fusion
        ekf_result = _wialon_2abc.update_ekf_with_sensor_data(truck_id, sensor_data)
        results["ekf"] = ekf_result
        logger.debug(f"[FASE 2A] EKF updated for {truck_id}: {ekf_result}")

        # ğŸ†• FASE 2B: Detect anomalies (fraud, sensor issues, etc.)
        anomaly_result = _wialon_2abc.detect_anomalies(truck_id, sensor_data)
        results["anomaly"] = anomaly_result
        if anomaly_result.get("anomaly_detected"):
            logger.warning(
                f"[FASE 2B] Anomaly detected for {truck_id}: "
                f"{anomaly_result.get('anomaly_type')} (confidence: {anomaly_result.get('confidence')})"
            )

        # ğŸ†• FASE 2B: Predict fuel consumption (LSTM)
        prediction_result = _wialon_2abc.predict_fuel_consumption(truck_id)
        results["prediction"] = prediction_result
        if prediction_result:
            logger.debug(
                f"[FASE 2B] LSTM prediction for {truck_id}: {prediction_result}"
            )

        # ğŸ†• FASE 2C: Publish event to bus
        event_id = _wialon_2abc.publish_event(
            "fuel_level_change",
            {
                "truck_id": truck_id,
                "fuel_level_pct": sensor_data.get("fuel_lvl"),
                "timestamp": sensor_data.get("timestamp", datetime.now(timezone.utc)),
                "ekf_result": ekf_result,
                "anomaly_result": anomaly_result,
            },
        )
        results["event_id"] = event_id

    except Exception as e:
        logger.error(f"Error processing 2ABC integrations for {truck_id}: {e}")

    return results


def update_sensors_cache(connection, metrics: Dict, sensor_data: Dict) -> bool:
    """
    ğŸ†• v6.4.1: Update truck_sensors_cache with latest sensor data.
    This replaces the need for sensor_cache_updater.py service.
    Uses RAW Wialon sensor names (same as sensor_cache_updater.py)
    """
    try:
        truck_id = metrics.get("truck_id")

        with connection.cursor() as cursor:
            # Helper to get sensor value (RAW Wialon names)
            def get_val(key, default=None):
                val = sensor_data.get(key, default)
                return val if val is not None else default

            # Convert timestamp from sensor_data
            from datetime import datetime, timezone

            # âœ… FIX: Usar columnas que existen en la tabla (epoch_time, last_updated)
            epoch_time = sensor_data.get("epoch_time", 0)
            last_updated = (
                datetime.fromtimestamp(epoch_time, tz=timezone.utc)
                if epoch_time
                else datetime.now(timezone.utc)
            )

            # Convertir last_updated a string ISO para MySQL
            last_updated_str = last_updated.strftime("%Y-%m-%d %H:%M:%S")

            # Preparar sensor_data como JSON para la columna json
            # Filtrar solo tipos serializables (nÃºmeros, strings, booleanos, None)
            serializable_data = {}
            for k, v in sensor_data.items():
                if k not in [
                    "epoch_time"
                ]:  # Excluir epoch_time que va en su propia columna
                    # Solo incluir tipos JSON serializables
                    if isinstance(v, (int, float, str, bool, type(None))):
                        serializable_data[k] = v

            # ğŸ”§ DEC30 2025: Usar nombres RAW de Wialon (oil_lvl, gear, barometer, etc.)
            sensor_json = json.dumps(
                {
                    # Sensores con nombres RAW de Wialon
                    "oil_press": sensor_data.get("oil_press"),  # Oil pressure (psi)
                    "oil_temp": sensor_data.get("oil_temp"),  # Oil temp (Â°F)
                    "oil_lvl": sensor_data.get("oil_lvl"),  # Oil level (%) - RAW name
                    "def_level": sensor_data.get("def_level"),  # DEF level (%)
                    "engine_load": sensor_data.get("engine_load"),  # Engine load (%)
                    "rpm": sensor_data.get("rpm"),  # RPM
                    "cool_temp": sensor_data.get("cool_temp"),  # Coolant temp (Â°F)
                    "cool_lvl": sensor_data.get("cool_lvl"),  # Coolant level (%)
                    "fuel_lvl": sensor_data.get("fuel_lvl"),  # Fuel level (%)
                    "fuel_rate": sensor_data.get("fuel_rate"),  # Fuel rate (L/h)
                    "latitude": sensor_data.get("latitude"),
                    "longitude": sensor_data.get("longitude"),
                    "speed": sensor_data.get("speed"),  # Speed (mph)
                    "odom": sensor_data.get("odometer"),  # Odometer (km)
                    # ğŸ†• Sensores adicionales
                    "gear": sensor_data.get("gear"),  # Current gear
                    "barometer": sensor_data.get("barometer"),  # Barometric pressure
                    "intk_t": sensor_data.get("intake_air_temp"),  # Intake air temp
                    "air_temp": sensor_data.get("ambient_temp"),  # Ambient temperature
                    "pto_hours": sensor_data.get("pto_hours"),  # PTO hours
                    "brake_switch": sensor_data.get("brake_switch"),  # Brake active
                    "engine_hours": sensor_data.get("engine_hours"),
                    "idle_hours": sensor_data.get("idle_hours"),
                    "total_fuel_used": sensor_data.get("total_fuel_used"),
                    # Incluir todos los demÃ¡s datos serializables
                    **serializable_data,
                }
            )

            # ğŸ†• v6.5.0 DEC30: Agregar obd_speed y engine_brake como columnas fÃ­sicas
            obd_speed_val = sensor_data.get("obd_speed")
            engine_brake_val = sensor_data.get("engine_brake")

            query = """
                INSERT INTO truck_sensors_cache (
                    truck_id, unit_id, epoch_time, last_updated, sensor_data,
                    obd_speed, engine_brake
                ) VALUES (%s, %s, %s, %s, %s, %s, %s)
                ON DUPLICATE KEY UPDATE
                    unit_id = VALUES(unit_id),
                    epoch_time = VALUES(epoch_time),
                    last_updated = VALUES(last_updated),
                    sensor_data = VALUES(sensor_data),
                    obd_speed = VALUES(obd_speed),
                    engine_brake = VALUES(engine_brake)
            """

            # Valores para el INSERT
            values = (
                truck_id,
                sensor_data.get("unit_id"),
                epoch_time,
                last_updated_str,
                sensor_json,
                obd_speed_val,
                engine_brake_val,
            )

            cursor.execute(query, values)

            logger.info(f"ğŸ“‹ Updated truck_sensors_cache for {truck_id}")
            return True

    except Exception as e:
        logger.error(
            f"âŒ Error updating sensors cache for {metrics.get('truck_id')}: {e}"
        )
        return False


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MAIN SYNC LOOP
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


def get_local_connection():
    return pymysql.connect(**LOCAL_DB_CONFIG)


# ğŸ†• v5.7.3: Track last reset date for idle validation
_last_idle_reset_date: Optional[str] = None


def _reset_idle_tracking_if_new_day(state_manager: "StateManager") -> None:
    """
    ğŸ†• v5.7.3: Reset idle_tracking accumulator at midnight for accurate daily validation.

    The idle validation compares our calculated idle hours vs ECU over 24h periods.
    Resetting daily ensures meaningful comparison windows.
    """
    global _last_idle_reset_date

    today = datetime.now(timezone.utc).strftime("%Y-%m-%d")

    if _last_idle_reset_date != today:
        if state_manager.idle_tracking:
            truck_count = len(state_manager.idle_tracking)
            # Reset calculated hours but keep ECU reference
            for truck_id in state_manager.idle_tracking:
                state_manager.idle_tracking[truck_id]["calc_idle_hours"] = 0.0
            logger.info(
                f"ğŸ”„ Daily idle tracking reset for {truck_count} trucks (new day: {today})"
            )
        _last_idle_reset_date = today


def sync_cycle(
    reader: WialonReader,
    local_conn,
    state_manager: StateManager,
    mpg_config: MPGConfig,
    idle_config: IdleConfig,
):
    """Single sync cycle with full Kalman processing - OPTIMIZED BATCH VERSION"""
    cycle_start = time.time()

    logger.info("â•" * 70)
    logger.info(
        f"ğŸ”„ ENHANCED SYNC CYCLE - {datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M:%S UTC')}"
    )
    logger.info("â•" * 70)

    # ğŸ†• v5.7.3: Daily reset of idle_tracking for accurate validation
    _reset_idle_tracking_if_new_day(state_manager)

    total_inserted = 0
    trucks_processed = 0
    status_counts = {
        "MOVING": 0,
        "STOPPED": 0,
        "PARKED": 0,
        "OFFLINE": 0,
        "NO_DATA": 0,
    }
    refuel_count = 0

    # ğŸš€ OPTIMIZED: Get ALL truck data in ONE batch query
    logger.info("ğŸ“Š Fetching data for all trucks in batch...")
    all_truck_data = reader.get_all_trucks_data()

    if not all_truck_data:
        logger.warning("âš ï¸ No truck data retrieved from Wialon")
        return

    logger.info(f"âœ… Retrieved data for {len(all_truck_data)} trucks")

    # Process each truck's data
    for truck_data in all_truck_data:
        truck_id = truck_data.truck_id
        try:
            # Convert TruckSensorData to dict format expected by process_truck
            sensor_data = {
                "unit_id": truck_data.unit_id,  # ğŸ†• v6.4.1: For sensors cache
                "epoch_time": truck_data.epoch_time,  # ğŸ†• v6.4.1: For sensors cache
                "timestamp": truck_data.timestamp,
                "latitude": getattr(truck_data, "latitude", None),
                "longitude": getattr(truck_data, "longitude", None),
                "speed": truck_data.speed,
                "rpm": truck_data.rpm,
                "fuel_lvl": truck_data.fuel_lvl,
                "fuel_rate": truck_data.fuel_rate,
                "odometer": truck_data.odometer,
                "altitude": truck_data.altitude,
                "engine_hours": truck_data.engine_hours,
                "hdop": truck_data.hdop,
                "coolant_temp": truck_data.coolant_temp,
                "total_fuel_used": truck_data.total_fuel_used,
                "pwr_ext": truck_data.pwr_ext,
                "engine_load": truck_data.engine_load,
                "oil_press": truck_data.oil_press,
                "oil_temp": truck_data.oil_temp,
                "def_level": truck_data.def_level,
                "intake_air_temp": truck_data.intake_air_temp,
                # ğŸ†• v3.12.28 / v5.7.5: Sensors for DTC, GPS quality, idle validation
                "dtc": truck_data.dtc,  # May be just 0/1 flag
                "dtc_code": truck_data.dtc_code,  # v5.7.5: Actual DTC codes like "100.4,157.3"
                "idle_hours": truck_data.idle_hours,
                "sats": truck_data.sats,
                "pwr_int": truck_data.pwr_int,
                "course": truck_data.course,
                # ğŸ†• v5.10.0: Driver behavior & MPG cross-validation sensors
                "fuel_economy": getattr(truck_data, "fuel_economy", None),  # ECU MPG
                "gear": getattr(truck_data, "gear", None),  # Current gear position
                "barometer": getattr(
                    truck_data, "barometer", None
                ),  # Barometric pressure
                # ğŸ†• v5.10.1: Full Pacific Track sensor suite
                # Temperatures
                "fuel_temp": getattr(truck_data, "fuel_temp", None),
                "fuel_t": getattr(truck_data, "fuel_temp", None),  # âœ… RAW Wialon name
                "intercooler_temp": getattr(truck_data, "intercooler_temp", None),
                "intrclr_t": getattr(
                    truck_data, "intercooler_temp", None
                ),  # âœ… RAW Wialon name
                "turbo_temp": getattr(truck_data, "turbo_temp", None),
                "trans_temp": getattr(truck_data, "trans_temp", None),
                # Temperatures - Additional
                "def_temp": getattr(truck_data, "def_temp", None),
                "egr_temp": getattr(truck_data, "egr_temp", None),
                "cool_temp": truck_data.coolant_temp,  # âœ… RAW Wialon name
                "intk_t": truck_data.intake_air_temp,  # âœ… RAW Wialon name (Intake temp)
                "air_temp": truck_data.ambient_temp,  # âœ… RAW Wialon name (Ambient temp)
                # Pressures
                "intake_press": getattr(truck_data, "intake_press", None),
                "intake_pressure": getattr(truck_data, "intake_press", None),  # Alias
                "turbo_press": getattr(
                    truck_data, "turbo_press", None
                ),  # ğŸ”§ Correct Wialon name
                "fuel_press": getattr(truck_data, "fuel_press", None),
                "trans_press": getattr(truck_data, "trans_press", None),
                "dpf_press": getattr(
                    truck_data, "dpf_press", None
                ),  # ğŸ”§ Correct Wialon name
                # Levels & Quality
                "cool_lvl": getattr(truck_data, "cool_lvl", None),
                "def_quality": getattr(truck_data, "def_quality", None),
                "oil_lvl": getattr(
                    truck_data, "oil_level", None
                ),  # ğŸ”§ DEC30: Use oil_level attribute
                # Positions
                "throttle_pos": getattr(truck_data, "throttle_pos", None),
                "egr_pos": getattr(truck_data, "egr_pos", None),
                # DPF sensors
                "dpf_soot": getattr(truck_data, "dpf_soot", None),
                "dpf_ash": getattr(truck_data, "dpf_ash", None),
                "dpf_status": getattr(truck_data, "dpf_status", None),
                # Other
                "alternator_status": getattr(
                    truck_data, "alternator_status", None
                ),  # ğŸ”§ Correct name
                "odom": truck_data.odometer,  # âœ… RAW Wialon name for odometer
                # Counters (need RAW names)
                "engine_hours": truck_data.engine_hours,  # Already mapped correctly
                "idle_hours": truck_data.idle_hours,  # Already mapped correctly
                "total_fuel_used": truck_data.total_fuel_used,  # Already mapped correctly
                "total_idle_fuel": (
                    truck_data.total_idle_fuel
                    if hasattr(truck_data, "total_idle_fuel")
                    else None
                ),
                # Brake
                "brake_switch": getattr(
                    truck_data, "brake_switch", None
                ),  # âœ… RAW Wialon name
                # Counters
                "pto_hours": getattr(truck_data, "pto_hours", None),
                # Brake Info
                "brake_app_press": getattr(truck_data, "brake_app_press", None),
                "brake_primary_press": getattr(truck_data, "brake_primary_press", None),
                "brake_secondary_press": getattr(
                    truck_data, "brake_secondary_press", None
                ),
                "brake_switch": getattr(truck_data, "brake_switch", None),
                "parking_brake": getattr(truck_data, "parking_brake", None),
                "abs_status": getattr(truck_data, "abs_status", None),
                # Driving events (from accelerometer)
                "harsh_accel": getattr(truck_data, "harsh_accel", None),
                "harsh_brake": getattr(truck_data, "harsh_brake", None),
                "harsh_corner": getattr(truck_data, "harsh_corner", None),
                # ğŸ†• v6.5.0 DEC30: Additional critical sensors
                "obd_speed": getattr(truck_data, "obd_speed", None),
                "engine_brake": getattr(truck_data, "engine_brake", None),
            }

            # ğŸ†• v5.10.0: Process driver behavior detection
            try:
                behavior_engine = get_behavior_engine()
                behavior_events = behavior_engine.process_reading(
                    truck_id=truck_id,
                    timestamp=truck_data.timestamp,
                    speed=truck_data.speed,
                    rpm=truck_data.rpm,
                    gear=getattr(truck_data, "gear", None),
                    fuel_rate=truck_data.fuel_rate,
                    fuel_economy=getattr(truck_data, "fuel_economy", None),
                    # ğŸ†• v5.10.1: Pass brake info for brake event detection
                    brake_switch=getattr(truck_data, "brake_switch", None),
                    brake_pressure=getattr(truck_data, "brake_app_press", None),
                    # ğŸ†• v5.10.1: Pass device-detected harsh events
                    device_harsh_accel=getattr(truck_data, "harsh_accel", None),
                    device_harsh_brake=getattr(truck_data, "harsh_brake", None),
                )
                # Log severe behavior events
                for event in behavior_events:
                    if event.severity.value in ["severe", "critical"]:
                        logger.warning(
                            f"âš ï¸ [{truck_id}] {event.behavior_type.value}: "
                            f"{event.value:.2f} (threshold: {event.threshold:.2f})"
                        )
            except Exception as behavior_error:
                logger.debug(
                    f"Behavior detection error for {truck_id}: {behavior_error}"
                )

            # ğŸ†• v5.11.0: Feed predictive maintenance engine with sensor data
            try:
                pm_engine = get_predictive_maintenance_engine()
                pm_engine.process_sensor_batch(
                    truck_id=truck_id,
                    sensor_data={
                        # Engine sensors
                        "oil_pressure": truck_data.oil_pressure,
                        "coolant_temp": truck_data.coolant_temp,
                        "oil_temp": truck_data.oil_temp,
                        # Turbo sensors (may be None until Pacific Track enables them)
                        "turbo_temp": getattr(truck_data, "turbo_temp", None),
                        "boost_pressure": getattr(truck_data, "boost_pressure", None),
                        "intercooler_temp": getattr(
                            truck_data, "intercooler_temp", None
                        ),
                        # Transmission
                        "trans_temp": getattr(truck_data, "trans_temp", None),
                        # Fuel system
                        "fuel_temp": getattr(truck_data, "fuel_temp", None),
                        # Electrical
                        "battery_voltage": truck_data.battery,
                        # DEF
                        "def_level": truck_data.def_level,
                        # Brakes
                        "brake_air_pressure": getattr(
                            truck_data, "brake_app_press", None
                        ),
                        # Efficiency (from MPG engine)
                        "mpg": sensor_data.get("mpg"),
                    },
                    timestamp=truck_data.timestamp,
                )
            except Exception as pm_error:
                logger.debug(f"Predictive maintenance error for {truck_id}: {pm_error}")

            # ğŸ†• v3.12.28 / v5.7.5: Process DTC codes and generate alerts
            # Prefer dtc_code (actual codes like "100.4,157.3") over dtc (which may be just 0/1 flag)
            dtc_to_process = (
                truck_data.dtc_code
                if truck_data.dtc_code
                else (
                    truck_data.dtc
                    if truck_data.dtc
                    and str(truck_data.dtc) not in ["0", "1", "0.0", "1.0"]
                    else None
                )
            )
            # ğŸ”§ DEC 26 2025: OLD DTC SYSTEM DISABLED - NOW USING HYBRID DECODER ONLY
            # The old system (dtc_analyzer.py) has been replaced with the new hybrid system
            # that provides 100% DTC coverage (781,066 DTCs) with OEM detection

            # ğŸ”§ DEC 26 2025: NEW HYBRID SYSTEM (781,066 DTCs):
            # Replaces the old dtc_analyzer.py system entirely
            if dtc_to_process:
                try:
                    # Initialize handler (singleton pattern)
                    if not hasattr(state_manager, "_dtc_handler"):
                        state_manager._dtc_handler = FuelCopilotDTCHandler()

                    # Parse Wialon DTC string: "100.1,157.3" â†’ [(100,1), (157,3)]
                    dtc_pairs = parse_wialon_dtc_string(str(dtc_to_process))

                    if not dtc_pairs:
                        logger.debug(f"No valid DTCs in: {dtc_to_process}")
                    else:
                        logger.info(
                            f"ğŸ” Processing {len(dtc_pairs)} DTC(s) for {truck_id}: {dtc_to_process}"
                        )

                    for spn, fmi in dtc_pairs:
                        # Process with HYBRID decoder
                        dtc_result = state_manager._dtc_handler.process_wialon_dtc(
                            truck_id=truck_id, spn=spn, fmi=fmi
                        )

                        # Save to database with HYBRID info
                        save_dtc_event_hybrid(
                            local_conn,
                            truck_id=truck_id,
                            dtc_info=dtc_result,
                        )

                        # ğŸ†• DEC 30 2025: Send DTC alert to FleetBooster
                        try:
                            from fleetbooster_integration import (
                                send_dtc_alert as send_fb_dtc,
                            )

                            send_fb_dtc(
                                truck_id=truck_id,
                                dtc_code=dtc_result.get("dtc_code", "UNKNOWN"),
                                dtc_description=dtc_result.get(
                                    "description", "Unknown DTC"
                                ),
                                severity=dtc_result.get("severity", "WARNING"),
                                system=dtc_result.get("category", "System"),
                            )
                        except Exception as fb_err:
                            logger.debug(
                                f"[{truck_id}] FleetBooster DTC alert failed: {fb_err}"
                            )

                        # Send alerts based on severity
                        if dtc_result.get("is_critical"):
                            detailed = (
                                "âœ¨ DETAILED"
                                if dtc_result.get("has_detailed_info")
                                else "ğŸ“‹ COMPLETE"
                            )
                            logger.warning(
                                f"ğŸš¨ CRITICAL DTC ({detailed}): {truck_id} - "
                                f"{dtc_result['dtc_code']} - {dtc_result['description']}"
                            )
                            # Send alert with HYBRID system info
                            send_dtc_alert(truck_id=truck_id, dtc_info=dtc_result)

                        elif dtc_result.get("severity") == "WARNING":
                            detailed = (
                                "âœ¨ DETAILED"
                                if dtc_result.get("has_detailed_info")
                                else "ğŸ“‹ COMPLETE"
                            )
                            logger.info(
                                f"âš ï¸ DTC Warning ({detailed}): {truck_id} - "
                                f"{dtc_result['dtc_code']} - {dtc_result['description']}"
                            )
                            # Send email for warnings (SMS only for CRITICAL)
                            send_dtc_alert(truck_id=truck_id, dtc_info=dtc_result)

                except Exception as hybrid_dtc_error:
                    logger.error(
                        f"HYBRID DTC processing error for {truck_id}: {hybrid_dtc_error}",
                        exc_info=True,
                    )

            # ğŸ†• v3.12.28 / v5.7.5: Process voltage alerts using pwr_ext (truck battery)
            # NOTE: pwr_int is GPS tracker backup battery (~3.78V), NOT truck voltage
            if truck_data.pwr_ext is not None:
                try:
                    is_running = (truck_data.rpm or 0) > 100
                    voltage_alert = analyze_voltage(
                        voltage=truck_data.pwr_ext,  # v5.7.5: Use pwr_ext (truck 12-14V)
                        rpm=truck_data.rpm,
                        truck_id=truck_id,
                    )
                    # Only process non-OK alerts through the manager
                    if voltage_alert and voltage_alert.priority != "OK":
                        alert_mgr = get_voltage_alert_manager()
                        should_send = alert_mgr.process_alert(voltage_alert)
                        if should_send:
                            if voltage_alert.priority == "CRITICAL":
                                logger.warning(
                                    f"ğŸ”‹ CRITICAL VOLTAGE: {voltage_alert.message}"
                                )
                                # ğŸ†• v5.7.3: Send notification via alert_service
                                send_voltage_alert(
                                    truck_id=truck_id,
                                    voltage=truck_data.pwr_ext,
                                    priority_level="CRITICAL",
                                    message=voltage_alert.message,
                                    is_engine_running=is_running,
                                )
                            else:
                                logger.info(
                                    f"ğŸ”‹ Voltage Warning: {truck_id} - {voltage_alert.message}"
                                )
                                # ğŸ†• v5.7.3: Send email-only for warnings
                                send_voltage_alert(
                                    truck_id=truck_id,
                                    voltage=truck_data.pwr_ext,
                                    priority_level="WARNING",
                                    message=voltage_alert.message,
                                    is_engine_running=is_running,
                                )
                except Exception as volt_error:
                    logger.debug(
                        f"Voltage processing error for {truck_id}: {volt_error}"
                    )

            # ğŸ†• v3.12.28: Log GPS quality for monitoring
            if truck_data.sats is not None:
                try:
                    gps_result = analyze_gps_quality(
                        satellites=truck_data.sats,
                        truck_id=truck_id,
                    )
                    if gps_result.quality == GPSQuality.CRITICAL:
                        logger.warning(
                            f"ğŸ“¡ GPS Critical: {truck_id} - only {truck_data.sats} satellites"
                        )
                    elif gps_result.quality == GPSQuality.POOR:
                        logger.debug(
                            f"ğŸ“¡ GPS Poor: {truck_id} - {truck_data.sats} satellites"
                        )
                except Exception as gps_error:
                    logger.debug(f"GPS quality error for {truck_id}: {gps_error}")

            # ğŸ†• v5.7.2: Full idle validation against ECU
            if (
                truck_data.idle_hours is not None
                and truck_data.engine_hours is not None
            ):
                try:
                    # Initialize tracking for this truck if needed
                    if truck_id not in state_manager.idle_tracking:
                        state_manager.idle_tracking[truck_id] = {
                            "calc_idle_hours": 0.0,
                            "last_ecu_idle": truck_data.idle_hours,
                            "last_check": datetime.now(timezone.utc).isoformat(),
                        }

                    tracking = state_manager.idle_tracking[truck_id]

                    # Get our calculated idle from this cycle (if truck was idle)
                    # We track it after metrics processing below

                    # Validate against ECU using the proper function
                    validation = validate_idle_calculation(
                        truck_id=truck_id,
                        calculated_idle_hours=tracking["calc_idle_hours"],
                        ecu_idle_hours=truck_data.idle_hours,
                        ecu_engine_hours=truck_data.engine_hours,
                        time_period_hours=24.0,  # Rolling 24h window
                    )

                    if validation.needs_investigation:
                        logger.warning(
                            f"âš ï¸ Idle validation issue: {validation.message} "
                            f"(deviation: {validation.deviation_pct:.1f}%)"
                        )
                    elif validation.confidence == "HIGH":
                        logger.debug(
                            f"âœ… Idle validation OK: {truck_id} - {validation.message}"
                        )

                    # Update ECU reference for next cycle
                    tracking["last_ecu_idle"] = truck_data.idle_hours
                    tracking["last_check"] = datetime.now(timezone.utc).isoformat()

                except Exception as idle_val_error:
                    logger.debug(
                        f"Idle validation error for {truck_id}: {idle_val_error}"
                    )

            # ğŸ†• v5.12.0: Check for missed refuels in historical data
            # This fixes the issue where only ONE refuel per sync cycle was detected
            # Example: PC1280 on Dec 17 had TWO refuels but only first was detected
            try:
                # Get last 24 hours of fuel data for this truck
                fuel_history = reader.get_truck_fuel_history(
                    truck_id=truck_id, hours_back=24, limit=100
                )

                if len(fuel_history) >= 2:
                    # Get truck config for tank capacity
                    from truck_mapping import TRUCK_CONFIG

                    truck_config = TRUCK_CONFIG.get(truck_id, {})
                    tank_capacity = truck_config.get("capacity_gallons", 200)

                    # Get estimator for Kalman baseline
                    estimator = state_manager.get_estimator(truck_id)

                    # Detect all refuels in the history
                    historical_refuels = detect_multiple_refuels(
                        fuel_history=fuel_history,
                        estimator=estimator,
                        tank_capacity_gal=tank_capacity,
                        truck_id=truck_id,
                    )

                    # Save any newly detected refuels to database
                    for refuel in historical_refuels:
                        refuel_timestamp = refuel.get("timestamp")
                        gallons = refuel.get("increase_gal", 0)
                        fuel_before = refuel.get("prev_pct", 0)
                        fuel_after = refuel.get("new_pct", 0)

                        # Check if this refuel is already in database
                        # (avoid duplicates from previous sync cycles)
                        saved = save_refuel_event(
                            connection=local_conn,
                            truck_id=truck_id,
                            timestamp_utc=refuel_timestamp,
                            fuel_before=fuel_before,
                            fuel_after=fuel_after,
                            gallons_added=gallons,
                            latitude=sensor_data.get("latitude"),
                            longitude=sensor_data.get("longitude"),
                            refuel_type="HISTORICAL",
                        )

                        if saved:
                            refuel_count += 1
                            logger.info(
                                f"ğŸ’¾ [HISTORICAL-REFUEL] {truck_id} @ {refuel_timestamp}: "
                                f"+{gallons:.1f} gal saved to database"
                            )

            except Exception as hist_refuel_error:
                logger.debug(
                    f"Historical refuel detection error for {truck_id}: {hist_refuel_error}"
                )

            # Full processing with Kalman
            metrics = process_truck(
                truck_id=truck_id,
                sensor_data=sensor_data,
                state_manager=state_manager,
                mpg_config=mpg_config,
                idle_config=idle_config,
            )

            # Skip if processing failed
            if metrics is None:
                logger.warning(f"âš ï¸ {truck_id}: Processing returned None, skipping save")
                continue

            # Save to database
            inserted = save_to_fuel_metrics(local_conn, metrics)
            total_inserted += inserted

            # ğŸ†• DEC 30 2025: Send fuel level to FleetBooster (every 60 sec)
            try:
                send_fuel_level_update(
                    truck_id=truck_id,
                    fuel_pct=metrics.get("estimated_pct", metrics.get("sensor_pct", 0)),
                    fuel_gallons=metrics.get(
                        "estimated_gallons", metrics.get("sensor_gallons", 0)
                    ),
                    fuel_source="kalman" if metrics.get("estimated_pct") else "sensor",
                    estimated_liters=metrics.get("estimated_liters"),
                )
            except Exception as e:
                logger.debug(f"[{truck_id}] FleetBooster fuel update failed: {e}")

            # ğŸ†• FASES 2A, 2B, 2C: Process through ML pipeline + Event Bus
            try:
                integration_results = process_2abc_integrations(truck_id, sensor_data)
                if integration_results:
                    logger.debug(
                        f"[{truck_id}] 2ABC Integration results: "
                        f"EKF={bool(integration_results.get('ekf'))}, "
                        f"Anomaly={bool(integration_results.get('anomaly'))}, "
                        f"Event={integration_results.get('event_id')}"
                    )
            except Exception as e:
                logger.warning(f"[{truck_id}] 2ABC integration error: {e}")

            # ğŸ†• v6.4.1: Update sensors cache (replaces sensor_cache_updater.py)
            update_sensors_cache(local_conn, metrics, sensor_data)

            trucks_processed += 1

            # ğŸ†• v5.7.2: Track calculated idle hours for ECU validation
            if metrics.get("idle_mode") != "ENGINE_OFF" and metrics.get("idle_gph"):
                # If truck was idle this cycle, accumulate the idle time
                # Sync interval is typically 30 seconds = 0.00833 hours
                if truck_id in state_manager.idle_tracking:
                    idle_hours_this_cycle = 30 / 3600  # 30 seconds in hours
                    state_manager.idle_tracking[truck_id][
                        "calc_idle_hours"
                    ] += idle_hours_this_cycle

            # Track status
            status = metrics["truck_status"]
            status_counts[status] = status_counts.get(status, 0) + 1

            # Handle refuel detection - SAVE IMMEDIATELY
            # ğŸ”§ v5.17.1: Save refuel immediately instead of buffering
            # Previous approach used add_pending_refuel() which waited 15 min
            # This caused data loss when service restarted or errors occurred
            if metrics.get("refuel_detected") == "YES" and metrics.get("refuel_event"):
                refuel_count += 1
                refuel_evt = metrics["refuel_event"]

                # Calculate fuel percentages
                fuel_before = metrics.get("fuel_before_pct") or 0
                fuel_after = metrics.get("sensor_pct") or 0
                gallons_added = refuel_evt.get("increase_gal", 0)

                # ğŸ”§ v5.17.1: Save immediately to prevent data loss
                try:
                    # ğŸ†• MEJORA-001: Logging detallado para diagnÃ³stico de refuels
                    logger.info(
                        f"ğŸ’§ REFUEL DETECTED [{truck_id}] "
                        f"gallons={gallons_added:.1f} ({fuel_before:.1f}% â†’ {fuel_after:.1f}%) "
                        f"detection_method={refuel_evt.get('method', 'unknown')} "
                        f"confidence={refuel_evt.get('confidence', 0):.0f}% "
                        f"location={metrics.get('latitude', 'N/A')},{metrics.get('longitude', 'N/A')}"
                    )

                    was_saved = save_refuel_event(
                        connection=local_conn,
                        truck_id=truck_id,
                        timestamp_utc=metrics["timestamp_utc"],
                        fuel_before=fuel_before,
                        fuel_after=fuel_after,
                        gallons_added=gallons_added,
                        latitude=metrics.get("latitude"),
                        longitude=metrics.get("longitude"),
                        refuel_type="DETECTED",
                    )
                    if was_saved:
                        logger.info(
                            f"âœ… [{truck_id}] Refuel SAVED: "
                            f"{fuel_before:.1f}% â†’ {fuel_after:.1f}% "
                            f"(+{gallons_added:.1f} gal)"
                        )

                        # ğŸ†• v3.12.32 QUICK WIN #1: Register confirmed refuel for adaptive learning
                        pct_jump = fuel_after - fuel_before
                        adaptive = get_adaptive_thresholds()
                        adaptive.record_confirmed_refuel(
                            truck_id=truck_id,
                            pct_jump=pct_jump,
                            gallons=gallons_added,
                            confidence=0.9,  # High confidence for saved refuels
                        )

                        # Send notification for successfully saved refuels
                        send_refuel_notification(
                            truck_id=truck_id,
                            gallons_added=gallons_added,
                            fuel_before=fuel_before,
                            fuel_after=fuel_after,
                            timestamp_utc=metrics["timestamp_utc"],
                        )
                    else:
                        logger.warning(
                            f"âš ï¸ [{truck_id}] Refuel detected but not saved (likely duplicate)"
                        )
                except Exception as e:
                    logger.error(f"âŒ [{truck_id}] Error saving refuel: {e}")
                    import traceback

                    traceback.print_exc()

                # ğŸ†• v3.12.27: Process fuel events with intelligent classification
                # This differentiates THEFT from SENSOR_ISSUE by monitoring recovery
                try:
                    fuel_classifier = get_fuel_classifier()
                    last_sensor = metrics.get("fuel_before_pct") or 0
                    current_sensor = metrics.get("sensor_pct") or 0

                    if last_sensor > 0 and current_sensor > 0:
                        location = None
                        if metrics.get("latitude") and metrics.get("longitude"):
                            location = f"({metrics['latitude']:.4f}, {metrics['longitude']:.4f})"

                        # Get tank capacity for this truck
                        tank_cap = TANK_CAPACITIES.get(
                            truck_id, TANK_CAPACITIES.get("default", 200.0)
                        )

                        fuel_event = fuel_classifier.process_fuel_reading(
                            truck_id=truck_id,
                            last_fuel_pct=last_sensor,
                            current_fuel_pct=current_sensor,
                            tank_capacity_gal=tank_cap,
                            location=location,
                            truck_status=metrics.get("truck_status", "UNKNOWN"),
                        )

                        if fuel_event:
                            classification = fuel_event.get("classification")

                            if classification == "THEFT_CONFIRMED":
                                # Fuel stayed low - confirmed theft
                                logger.warning(
                                    f"ğŸš¨ {truck_id}: THEFT CONFIRMED - sending alert"
                                )
                                send_theft_confirmed_alert(
                                    truck_id=truck_id,
                                    fuel_drop_gallons=fuel_event.get("drop_gal", 0),
                                    fuel_drop_pct=fuel_event.get("drop_pct", 0),
                                    time_waited_minutes=fuel_event.get(
                                        "time_waited_minutes", 0
                                    ),
                                    location=location,
                                )

                            elif classification == "SENSOR_ISSUE":
                                # Fuel recovered - sensor problem
                                logger.info(
                                    f"ğŸ”§ {truck_id}: SENSOR ISSUE detected - sending maintenance alert"
                                )
                                recovery_info = (
                                    f"Dropped from {fuel_event.get('original_fuel_pct', 0):.1f}% "
                                    f"to {fuel_event.get('drop_fuel_pct', 0):.1f}%, "
                                    f"recovered to {fuel_event.get('current_fuel_pct', 0):.1f}%"
                                )
                                send_sensor_issue_alert(
                                    truck_id=truck_id,
                                    drop_pct=fuel_event.get("drop_pct", 0),
                                    drop_gal=fuel_event.get("drop_gal", 0),
                                    recovery_info=recovery_info,
                                    volatility=fuel_classifier.get_sensor_volatility(
                                        truck_id
                                    ),
                                )

                            elif classification == "THEFT_SUSPECTED":
                                # Extreme drop while stopped - immediate alert
                                logger.warning(
                                    f"ğŸš¨ {truck_id}: THEFT SUSPECTED (extreme drop)"
                                )
                                # This is handled by the old system already

                            elif classification == "PENDING_VERIFICATION":
                                # Drop detected, waiting for recovery check
                                logger.info(f"â³ {truck_id}: Drop pending verification")

                            # Log all classified events
                            logger.debug(
                                f"ğŸ“Š {truck_id}: Fuel event classified as {classification}"
                            )

                except Exception as e:
                    logger.error(f"Error in fuel classifier for {truck_id}: {e}")

                # Log with details
                status_emoji = {
                    "MOVING": "ğŸš›",
                    "STOPPED": "â¸ï¸",
                    "PARKED": "ğŸ…¿ï¸",
                    "OFFLINE": "ğŸ“´",
                }.get(status, "â“")

                speed_str = (
                    f"{metrics['speed_mph']:.1f}" if metrics["speed_mph"] else "N/A"
                )
                sensor_str = (
                    f"{metrics['sensor_pct']:.1f}" if metrics["sensor_pct"] else "N/A"
                )
                kalman_str = (
                    f"{metrics['estimated_pct']:.1f}"
                    if metrics["estimated_pct"]
                    else "N/A"
                )
                drift_str = (
                    f"{metrics['drift_pct']:+.1f}" if metrics["drift_pct"] else "0.0"
                )
                mpg_str = (
                    f"{metrics['mpg_current']:.1f}" if metrics["mpg_current"] else "N/A"
                )

                logger.info(
                    f"{status_emoji} {truck_id}: {status} | "
                    f"Speed: {speed_str} | "
                    f"Sensor: {sensor_str}% | "
                    f"Kalman: {kalman_str}% | "
                    f"Drift: {drift_str}% | "
                    f"MPG: {mpg_str}"
                )
            else:
                status_counts["NO_DATA"] += 1
                logger.warning(f"âš ï¸ {truck_id}: No data from Wialon")

        except Exception as e:
            logger.error(f"Error processing {truck_id}: {e}")
            import traceback

            traceback.print_exc()

    # ğŸ”§ v5.17.1: Reduced timeout since refuels are now saved immediately
    # This is just a safety net for backwards compatibility
    stale_refuels = flush_stale_pending_refuels(max_age_minutes=2)
    for finalized in stale_refuels:
        try:
            was_saved = save_refuel_event(
                connection=local_conn,
                truck_id=finalized["truck_id"],
                timestamp_utc=finalized["timestamp"],
                fuel_before=finalized["start_pct"],
                fuel_after=finalized["end_pct"],
                gallons_added=finalized["gallons"],
                refuel_type="GAP_DETECTED",
            )
            if was_saved:
                send_refuel_notification(
                    truck_id=finalized["truck_id"],
                    gallons_added=finalized["gallons"],
                    fuel_before=finalized["start_pct"],
                    fuel_after=finalized["end_pct"],
                    timestamp_utc=finalized["timestamp"],
                )
        except Exception as e:
            logger.error(f"Error saving stale refuel for {finalized['truck_id']}: {e}")

    # ğŸ†• v5.7.1: Cache latest sensor data for /alerts/diagnostics endpoint
    # Using file-based cache since sync is synchronous and cache_service is async
    try:
        import json
        from pathlib import Path

        cache_dir = Path("cache")
        cache_dir.mkdir(exist_ok=True)
        cache_file = cache_dir / "fleet_sensors.json"

        # Build sensor cache from all_truck_data (which is a list)
        sensor_cache = []
        for truck_data in all_truck_data:
            if truck_data:
                sensor_cache.append(
                    {
                        "truck_id": truck_data.truck_id,
                        "dtc": truck_data.dtc,
                        "dtc_code": truck_data.dtc_code,  # v5.7.5: Actual DTC codes
                        "pwr_ext": truck_data.pwr_ext,  # v5.7.5: Truck battery (12-14V)
                        "pwr_int": truck_data.pwr_int,  # GPS backup battery (3-4V)
                        "sats": truck_data.sats,
                        "rpm": truck_data.rpm,
                        "timestamp": (
                            truck_data.timestamp.isoformat()
                            if truck_data.timestamp
                            else None
                        ),
                    }
                )

        if sensor_cache:
            with open(cache_file, "w") as f:
                json.dump(
                    {
                        "data": sensor_cache,
                        "updated_at": datetime.now(timezone.utc).isoformat(),
                    },
                    f,
                )
            logger.debug(f"ğŸ“¦ Cached sensor data for {len(sensor_cache)} trucks")
    except Exception as cache_error:
        logger.debug(f"Could not cache sensor data: {cache_error}")

    # Save states periodically
    state_manager.save_states()

    cycle_duration = time.time() - cycle_start

    # Summary
    logger.info("â”€" * 70)
    logger.info("ğŸ“Š STATUS SUMMARY:")
    logger.info(
        f"   ğŸš› MOVING: {status_counts['MOVING']} | "
        f"â¸ï¸ STOPPED: {status_counts['STOPPED']} | "
        f"ğŸ…¿ï¸ PARKED: {status_counts['PARKED']} | "
        f"ğŸ“´ OFFLINE: {status_counts['OFFLINE']} | "
        f"â“ NO_DATA: {status_counts['NO_DATA']}"
    )
    if refuel_count > 0:
        logger.info(f"   â›½ REFUELS DETECTED: {refuel_count}")
    logger.info(
        f"â±ï¸ Cycle completed in {cycle_duration:.2f}s. "
        f"Trucks: {trucks_processed}, Records: {total_inserted}"
    )
    logger.info("")


def main():
    logger.info("ğŸš€ ENHANCED WIALON TO MYSQL SYNC v3.0 STARTING")
    logger.info(
        "   Features: Kalman Filter, MPG Tracking, Idle Analysis, Refuel Detection"
    )

    # Initialize state manager
    state_manager = StateManager()

    # Configuration
    mpg_config = MPGConfig()
    idle_config = IdleConfig()

    # ğŸ†• v5.4.6: Filter to only configured trucks from tanks.yaml
    allowed_trucks = get_allowed_trucks()
    filtered_mapping = {
        k: v for k, v in TRUCK_UNIT_MAPPING.items() if k in allowed_trucks
    }

    logger.info(f"ğŸ“‹ Total trucks in Wialon DB: {len(TRUCK_UNIT_MAPPING)}")
    logger.info(f"âœ… Configured trucks in tanks.yaml: {len(filtered_mapping)}")
    logger.info(f"ğŸ¯ Processing: {', '.join(sorted(filtered_mapping.keys()))}")

    # Initialize Wialon Reader with filtered mapping
    wialon_config = WialonConfig()
    reader = WialonReader(wialon_config, filtered_mapping)

    if not reader.connect():
        logger.error("âŒ Failed to connect to Remote Wialon DB")
        return

    # Connect to Local DB
    try:
        local_conn = get_local_connection()
        logger.info("âœ… Connected to Local MySQL")
    except Exception as e:
        logger.error(f"âŒ Failed to connect to Local MySQL: {e}")
        return

    try:
        while True:
            try:
                sync_cycle(reader, local_conn, state_manager, mpg_config, idle_config)
            except Exception as cycle_error:
                logger.error(f"âŒ Error in sync cycle: {cycle_error}")
                import traceback

                traceback.print_exc()
                logger.info("â³ Retrying in 15 seconds...")

            time.sleep(15)  # 15 second intervals

            # Keep connection alive
            try:
                local_conn.ping(reconnect=True)
            except Exception as ping_error:
                logger.error(f"âŒ Error pinging database: {ping_error}")
                try:
                    local_conn = get_local_connection()
                    logger.info("âœ… Reconnected to Local MySQL")
                except Exception as reconnect_error:
                    logger.error(f"âŒ Failed to reconnect: {reconnect_error}")

    except KeyboardInterrupt:
        logger.info("âš ï¸ KeyboardInterrupt - Stopping...")
        state_manager.save_states()
    except Exception as main_error:
        logger.error(f"âŒ FATAL ERROR in main loop: {main_error}")
        import traceback

        traceback.print_exc()
        state_manager.save_states()
    finally:
        logger.info("ğŸ”š Shutting down...")
        try:
            reader.disconnect()
        except (AttributeError, Exception) as e:
            logger.debug(f"Error disconnecting reader: {e}")
        try:
            local_conn.close()
        except (AttributeError, Exception) as e:
            logger.debug(f"Error closing connection: {e}")


if __name__ == "__main__":
    main()
